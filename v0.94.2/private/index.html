<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Private · SparseIR.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SparseIR.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../guide/">Guide</a></li><li><a class="tocitem" href="../public/">Public</a></li><li class="is-active"><a class="tocitem" href>Private</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Private</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Private</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SpM-lab/SparseIR.jl/blob/main/docs/src/private.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Private-names-index"><a class="docs-heading-anchor" href="#Private-names-index">Private names index</a><a id="Private-names-index-1"></a><a class="docs-heading-anchor-permalink" href="#Private-names-index" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Core.Int-Tuple{MatsubaraFreq}" href="#Core.Int-Tuple{MatsubaraFreq}"><code>Core.Int</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get prefactor <code>n</code> for the Matsubara frequency <code>ω = n*π/β</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/freq.jl#L89-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Integer-Tuple{MatsubaraFreq}" href="#Core.Integer-Tuple{MatsubaraFreq}"><code>Core.Integer</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get prefactor <code>n</code> for the Matsubara frequency <code>ω = n*π/β</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/freq.jl#L84-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.AbstractKernel" href="#SparseIR.AbstractKernel"><code>SparseIR.AbstractKernel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">(kernel::AbstractKernel)(x, y[, x₊, x₋])</code></pre><p>Evaluate <code>kernel</code> at point <code>(x, y)</code>.</p><p>The parameters <code>x₊</code> and <code>x₋</code>, if given, shall contain the values of <code>x - xₘᵢₙ</code> and <code>xₘₐₓ - x</code>, respectively. This is useful if either difference is to be formed and cancellation expected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/kernel.jl#L366-L374">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.AbstractKernel" href="#SparseIR.AbstractKernel"><code>SparseIR.AbstractKernel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractKernel</code></pre><p>Integral kernel <code>K(x, y)</code>.</p><p>Abstract base type for an integral kernel, i.e. a AbstractFloat binary function <span>$K(x, y)$</span> used in a Fredhold integral equation of the first kind:</p><p class="math-container">\[    u(x) = ∫ K(x, y) v(y) dy\]</p><p>where <span>$x ∈ [x_\mathrm{min}, x_\mathrm{max}]$</span> and  <span>$y ∈ [y_\mathrm{min}, y_\mathrm{max}]$</span>.  For its SVE to exist, the kernel must be square-integrable, for its singular values to decay exponentially, it must be smooth.</p><p>In general, the kernel is applied to a scaled spectral function <span>$ρ&#39;(y)$</span> as:</p><p class="math-container">\[    ∫ K(x, y) ρ&#39;(y) dy,\]</p><p>where <span>$ρ&#39;(y) = w(y) ρ(y)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/kernel.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.AbstractSVEHints" href="#SparseIR.AbstractSVEHints"><code>SparseIR.AbstractSVEHints</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractSVEHints</code></pre><p>Discretization hints for singular value expansion of a given kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/kernel.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.AbstractSampling" href="#SparseIR.AbstractSampling"><code>SparseIR.AbstractSampling</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractSampling</code></pre><p>Abstract type for sparse sampling.</p><p>Encodes the &quot;basis transformation&quot; of a propagator from the truncated IR basis coefficients <code>G_ir[l]</code> to time/frequency sampled on sparse points <code>G(x[i])</code> together with its inverse, a least squares fit:</p><pre><code class="nohighlight hljs">     ________________                   ___________________
    |                |    evaluate     |                   |
    |     Basis      |----------------&gt;|     Value on      |
    |  coefficients  |&lt;----------------|  sampling points  |
    |________________|      fit        |___________________|</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/sampling.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.Bosonic" href="#SparseIR.Bosonic"><code>SparseIR.Bosonic</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Bosonic statistics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/freq.jl#L23-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.CentrosymmSVE" href="#SparseIR.CentrosymmSVE"><code>SparseIR.CentrosymmSVE</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CentrosymmSVE &lt;: AbstractSVE</code></pre><p>SVE of centrosymmetric kernel in block-diagonal (even/odd) basis.</p><p>For a centrosymmetric kernel <code>K</code>, i.e., a kernel satisfying: <code>K(x, y) == K(-x, -y)</code>, one can make the following ansatz for the singular functions:</p><pre><code class="nohighlight hljs">u[l](x) = ured[l](x) + sign[l] * ured[l](-x)
v[l](y) = vred[l](y) + sign[l] * ured[l](-y)</code></pre><p>where <code>sign[l]</code> is either <code>+1</code> or <code>-1</code>.  This means that the singular value expansion can be block-diagonalized into an even and an odd part by (anti-)symmetrizing the kernel:</p><pre><code class="nohighlight hljs">K_even = K(x, y) + K(x, -y)
K_odd  = K(x, y) - K(x, -y)</code></pre><p>The <code>l</code>th basis function, restricted to the positive interval, is then the singular function of one of these kernels.  If the kernel generates a Chebyshev system [1], then even and odd basis functions alternate.</p><p>[1]: A. Karlin, Total Positivity (1968).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/sve.jl#L49-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.Fermionic" href="#SparseIR.Fermionic"><code>SparseIR.Fermionic</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Fermionic statistics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/freq.jl#L18-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.FreqRange" href="#SparseIR.FreqRange"><code>SparseIR.FreqRange</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Dense grid of frequencies in an implicit representation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/freq.jl#L150-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.LogisticKernelOdd" href="#SparseIR.LogisticKernelOdd"><code>SparseIR.LogisticKernelOdd</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LogisticKernelOdd &lt;: AbstractReducedKernel</code></pre><p>Fermionic analytical continuation kernel, odd.</p><p>In dimensionless variables <span>$x = 2τ/β - 1$</span>, <span>$y = βω/Λ$</span>, the fermionic integral kernel is a function on <span>$[-1, 1] × [-1, 1]$</span>:</p><p class="math-container">\[    K(x, y) = -\frac{\sinh(Λ x y / 2)}{\cosh(Λ y / 2)}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/kernel.jl#L122-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.NestedRule" href="#SparseIR.NestedRule"><code>SparseIR.NestedRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NestedRule{T}</code></pre><p>Nested quadrature rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/gauss.jl#L120-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.PiecewiseLegendreFT" href="#SparseIR.PiecewiseLegendreFT"><code>SparseIR.PiecewiseLegendreFT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PiecewiseLegendreFT &lt;: Function</code></pre><p>Fourier transform of a piecewise Legendre polynomial.</p><p>For a given frequency index <code>n</code>, the Fourier transform of the Legendre function is defined as:</p><pre><code class="nohighlight hljs">    p̂(n) == ∫ dx exp(im * π * n * x / (xmax - xmin)) p(x)</code></pre><p>The polynomial is continued either periodically (<code>freq=:even</code>), in which case <code>n</code> must be even, or antiperiodically (<code>freq=:odd</code>), in which case <code>n</code> must be odd.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/poly.jl#L232-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.PiecewiseLegendrePoly" href="#SparseIR.PiecewiseLegendrePoly"><code>SparseIR.PiecewiseLegendrePoly</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PiecewiseLegendrePoly &lt;: Function</code></pre><p>Piecewise Legendre polynomial.</p><p>Models a function on the interval <span>$[xmin, xmax]$</span> as a set of segments on the intervals <span>$S[i] = [a[i], a[i+1]]$</span>, where on each interval the function is expanded in scaled Legendre polynomials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/poly.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.PiecewiseLegendrePolyVector" href="#SparseIR.PiecewiseLegendrePolyVector"><code>SparseIR.PiecewiseLegendrePolyVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PiecewiseLegendrePolyVector{T}</code></pre><p>Alias for <code>Vector{PiecewiseLegendrePoly{T}}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/poly.jl#L152-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.PowerModel" href="#SparseIR.PowerModel"><code>SparseIR.PowerModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PowerModel</code></pre><p>Model from a high-frequency series expansion::</p><pre><code class="nohighlight hljs">A(iω) == sum(A[n] / (iω)^(n+1) for n in 1:N)</code></pre><p>where <span>$iω == i * π/2 * wn$</span> is a reduced imaginary frequency, i.e., <span>$wn$</span> is an odd/even number for fermionic/bosonic frequencies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/poly.jl#L215-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.ReducedKernel" href="#SparseIR.ReducedKernel"><code>SparseIR.ReducedKernel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReducedKernel</code></pre><p>Restriction of centrosymmetric kernel to positive interval.</p><p>For a kernel <span>$K$</span> on <span>$[-1, 1] × [-1, 1]$</span> that is centrosymmetric, i.e. <span>$K(x, y) = K(-x, -y)$</span>, it is straight-forward to show that the left/right singular vectors can be chosen as either odd or even functions.</p><p>Consequentially, they are singular functions of a reduced kernel <span>$K_\mathrm{red}$</span> on <span>$[0, 1] × [0, 1]$</span> that is given as either:</p><p class="math-container">\[    K_\mathrm{red}(x, y) = K(x, y) \pm K(x, -y)\]</p><p>This kernel is what this type represents. The full singular functions can be reconstructed by (anti-)symmetrically continuing them to the negative axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/kernel.jl#L100-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.RegularizedBoseKernelOdd" href="#SparseIR.RegularizedBoseKernelOdd"><code>SparseIR.RegularizedBoseKernelOdd</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RegularizedBoseKernelOdd &lt;: AbstractReducedKernel</code></pre><p>Bosonic analytical continuation kernel, odd.</p><p>In dimensionless variables <span>$x = 2 τ / β - 1$</span>, <span>$y = β ω / Λ$</span>, the fermionic integral kernel is a function on <span>$[-1, 1] × [-1, 1]$</span>:</p><p class="math-container">\[    K(x, y) = -y \frac{\sinh(Λ x y / 2)}{\sinh(Λ y / 2)}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/kernel.jl#L144-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.Rule" href="#SparseIR.Rule"><code>SparseIR.Rule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Rule{T&lt;:AbstractFloat}</code></pre><p>Quadrature rule.</p><p>Approximation of an integral over <code>[a, b]</code> by a sum over discrete points <code>x</code> with weights <code>w</code>:</p><p class="math-container">\[    ∫ f(x) ω(x) dx ≈ ∑_i f(x_i) w_i\]</p><p>where we generally have superexponential convergence for smooth <span>$f(x)$</span> in  the number of quadrature points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/gauss.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.SamplingSVE" href="#SparseIR.SamplingSVE"><code>SparseIR.SamplingSVE</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SamplingSVE &lt;: AbstractSVE</code></pre><p>SVE to SVD translation by sampling technique [1].</p><p>Maps the singular value expansion (SVE) of a kernel <code>kernel</code> onto the singular value decomposition of a matrix <code>A</code>.  This is achieved by choosing two sets of Gauss quadrature rules: <code>(x, wx)</code> and <code>(y, wy)</code> and approximating the integrals in the SVE equations by finite sums.  This implies that the singular values of the SVE are well-approximated by the singular values of the following matrix:</p><pre><code class="nohighlight hljs">A[i, j] = √(wx[i]) * K(x[i], y[j]) * √(wy[j])</code></pre><p>and the values of the singular functions at the Gauss sampling points can be reconstructed from the singular vectors <code>u</code> and <code>v</code> as follows:</p><pre><code class="nohighlight hljs">u[l,i] ≈ √(wx[i]) u[l](x[i])
v[l,j] ≈ √(wy[j]) u[l](y[j])</code></pre><p>[1] P. Hansen, Discrete Inverse Problems, Ch. 3.1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/sve.jl#L3-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.Statistics" href="#SparseIR.Statistics"><code>SparseIR.Statistics</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Statistics(zeta)</code></pre><p>Abstract type for quantum statistics (fermionic/bosonic/etc.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/freq.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.canonicalize!-Tuple{Any, Any}" href="#SparseIR.canonicalize!-Tuple{Any, Any}"><code>SparseIR.canonicalize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">canonicalize!(u, v)</code></pre><p>Canonicalize basis.</p><p>Each SVD <code>(u[l], v[l])</code> pair is unique only up to a global phase, which may differ from implementation to implementation and also platform. We fix that gauge by demanding <code>u[l](1) &gt; 0</code>. This ensures a diffeomorphic connection to the Legendre polynomials as <code>Λ → 0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/sve.jl#L273-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.check_domain-Tuple{Any, Any, Any}" href="#SparseIR.check_domain-Tuple{Any, Any, Any}"><code>SparseIR.check_domain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_domain(kernel, x, y)</code></pre><p>Check that <code>(x, y)</code> lies within <code>kernel</code>&#39;s domain and return it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/kernel.jl#L292-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.choose_accuracy-Tuple{Any, Any, Any}" href="#SparseIR.choose_accuracy-Tuple{Any, Any, Any}"><code>SparseIR.choose_accuracy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">choose_accuracy(ε, Twork[, svd_strat])</code></pre><p>Choose work type and accuracy based on specs and defaults</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/sve.jl#L236-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.compute_sve-Tuple{SparseIR.AbstractKernel}" href="#SparseIR.compute_sve-Tuple{SparseIR.AbstractKernel}"><code>SparseIR.compute_sve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_sve(kernel::AbstractKernel;
    Twork=nothing, ε=nothing, n_sv=typemax(Int),
    n_gauss=-1, T=Float64, svd_strat=:auto,
    sve_strat=iscentrosymmetric(kernel) ? CentrosymmSVE : SamplingSVE
)</code></pre><p>Perform truncated singular value expansion of a kernel.</p><p>Perform a truncated singular value expansion (SVE) of an integral kernel <code>kernel : [xmin, xmax] x [ymin, ymax] -&gt; ℝ</code>:</p><pre><code class="nohighlight hljs">kernel(x, y) == sum(s[l] * u[l](x) * v[l](y) for l in (1, 2, 3, ...)),</code></pre><p>where <code>s[l]</code> are the singular values, which are ordered in non-increasing fashion, <code>u[l](x)</code> are the left singular functions, which form an orthonormal system on <code>[xmin, xmax]</code>, and <code>v[l](y)</code> are the right singular functions, which form an orthonormal system on <code>[ymin, ymax]</code>.</p><p>The SVE is mapped onto the singular value decomposition (SVD) of a matrix by expanding the kernel in piecewise Legendre polynomials (by default by using a collocation).</p><p><strong>Arguments</strong></p><ul><li><code>ε::AbstractFloat</code>:  Relative cutoff for the singular values.</li><li><code>n_sv::Integer</code>: Maximum basis size. If given, only at most the <code>n_sv</code> most significant singular values and associated singular functions are returned.</li><li><code>n_gauss::Integer</code>: Order of Legendre polynomials. Defaults to hinted value by the kernel.</li><li><code>T</code>: Data type of the result.</li><li><code>Twork</code>: Working data type. Defaults to a data type with machine epsilon of at least <code>eps^2</code>, or otherwise most accurate data type available.</li><li><code>sve_strat</code>: SVE to SVD translation strategy. Defaults to SamplingSVE.</li><li><code>svd_strat</code>: SVD solver. Defaults to fast (ID/RRQR) based solution when accuracy goals are moderate, and more accurate Jacobi-based algorithm otherwise.</li></ul><p><strong>Return value</strong></p><p>Return tuple <code>(u, s, v)</code>, where:</p><ul><li><code>u::PiecewiseLegendrePoly</code>: the left singular functions</li><li><code>s::Vector</code>: singular values</li><li><code>v::PiecewiseLegendrePoly</code>: the right singular functions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/sve.jl#L89-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.compute_unl_inner-Tuple{SparseIR.PiecewiseLegendrePoly, Any}" href="#SparseIR.compute_unl_inner-Tuple{SparseIR.PiecewiseLegendrePoly, Any}"><code>SparseIR.compute_unl_inner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_unl_inner(poly, wn)</code></pre><p>Compute piecewise Legendre to Matsubara transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/poly.jl#L445-L449">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.conv_radius" href="#SparseIR.conv_radius"><code>SparseIR.conv_radius</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">conv_radius(kernel)</code></pre><p>Convergence radius of the Matsubara basis asymptotic model.</p><p>For improved relative numerical accuracy, the IR basis functions on the Matsubara axis <code>uhat(basis, n)</code> can be evaluated from an asymptotic expression for <code>abs(n) &gt; conv_radius</code>.  If <code>isinf(conv_radius)</code>, then the asymptotics are unused (the default).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/kernel.jl#L479-L488">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.default_matsubara_sampling_points-Tuple{SparseIR.AbstractBasis}" href="#SparseIR.default_matsubara_sampling_points-Tuple{SparseIR.AbstractBasis}"><code>SparseIR.default_matsubara_sampling_points</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_matsubara_sampling_points(basis; mitigate=true)</code></pre><p>Default sampling points on the imaginary frequency axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/basis.jl#L291-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.default_omega_sampling_points-Tuple{SparseIR.AbstractBasis}" href="#SparseIR.default_omega_sampling_points-Tuple{SparseIR.AbstractBasis}"><code>SparseIR.default_omega_sampling_points</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_omega_sampling_points(basis)</code></pre><p>Default sampling points on the real-frequency axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/basis.jl#L300-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.default_tau_sampling_points-Tuple{SparseIR.AbstractBasis}" href="#SparseIR.default_tau_sampling_points-Tuple{SparseIR.AbstractBasis}"><code>SparseIR.default_tau_sampling_points</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_tau_sampling_points(basis)</code></pre><p>Default sampling points on the imaginary time/<code>x</code> axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/basis.jl#L284-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.deriv" href="#SparseIR.deriv"><code>SparseIR.deriv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">deriv(poly)</code></pre><p>Get polynomial for the derivative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/poly.jl#L98-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.eval_matrix" href="#SparseIR.eval_matrix"><code>SparseIR.eval_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eval_matrix(T, basis, x)</code></pre><p>Return evaluation matrix from coefficients to sampling points. <code>T &lt;: AbstractSampling</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/sampling.jl#L115-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.findextrema" href="#SparseIR.findextrema"><code>SparseIR.findextrema</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">findextrema(polyFT::PiecewiseLegendreFT, part=nothing, grid=DEFAULT_GRID)</code></pre><p>Obtain extrema of fourier-transformed polynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/poly.jl#L325-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.finite_temp_bases" href="#SparseIR.finite_temp_bases"><code>SparseIR.finite_temp_bases</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">finite_temp_bases(β, wmax, ε, sve_result=compute_sve(LogisticKernel(β * wmax); ε))</code></pre><p>Construct <code>FiniteTempBasis</code> objects for fermion and bosons using the same <code>LogisticKernel</code> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/basis.jl#L271-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.get_symmetrized-Tuple{SparseIR.AbstractKernel, Any}" href="#SparseIR.get_symmetrized-Tuple{SparseIR.AbstractKernel, Any}"><code>SparseIR.get_symmetrized</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_symmetrized(kernel, sign)</code></pre><p>Construct a symmetrized version of <code>kernel</code>, i.e. <code>kernel(x, y) + sign * kernel(x, -y)</code>.</p><div class="admonition is-warning"><header class="admonition-header">Beware!</header><div class="admonition-body"><p>By default, this returns a simple wrapper over the current instance which naively performs the sum. You may want to override this to avoid cancellation.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/kernel.jl#L314-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.get_tnl-Tuple{Any, Any}" href="#SparseIR.get_tnl-Tuple{Any, Any}"><code>SparseIR.get_tnl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_tnl(l, w)</code></pre><p>Fourier integral of the <code>l</code>-th Legendre polynomial::</p><pre><code class="nohighlight hljs">Tₗ(ω) == ∫ dx exp(iωx) Pₗ(x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/poly.jl#L466-L472">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.getwmax-Tuple{FiniteTempBasis}" href="#SparseIR.getwmax-Tuple{FiniteTempBasis}"><code>SparseIR.getwmax</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getwmax(basis::FiniteTempBasis)</code></pre><p>Real frequency cutoff.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/basis.jl#L264-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.getΛ-Tuple{DimensionlessBasis}" href="#SparseIR.getΛ-Tuple{DimensionlessBasis}"><code>SparseIR.getΛ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getΛ(basis)</code></pre><p>Basis cutoff parameter <code>Λ = β * ωmax</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/basis.jl#L113-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.giw-Tuple{Any, Integer}" href="#SparseIR.giw-Tuple{Any, Integer}"><code>SparseIR.giw</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">giw(polyFT, wn)</code></pre><p>Return model Green&#39;s function for reduced frequencies</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/poly.jl#L301-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.iscentrosymmetric" href="#SparseIR.iscentrosymmetric"><code>SparseIR.iscentrosymmetric</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_centrosymmetric(kernel)</code></pre><p>Return <code>true</code> if <code>kernel(x, y) == kernel(-x, -y)</code> for all values of <code>x</code> and <code>y</code> in range. This allows the kernel to be block-diagonalized, speeding up the singular value expansion by a factor of 4. Defaults to <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/kernel.jl#L353-L359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.iswellconditioned-Tuple{DimensionlessBasis}" href="#SparseIR.iswellconditioned-Tuple{DimensionlessBasis}"><code>SparseIR.iswellconditioned</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iswellconditioned(basis)</code></pre><p>Return <code>true</code> if the sampling is expected to be well-conditioned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/basis.jl#L249-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.joinrules-Union{Tuple{AbstractArray{SparseIR.Rule{T}, 1}}, Tuple{T}} where T&lt;:AbstractFloat" href="#SparseIR.joinrules-Union{Tuple{AbstractArray{SparseIR.Rule{T}, 1}}, Tuple{T}} where T&lt;:AbstractFloat"><code>SparseIR.joinrules</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">joinrules(rules)</code></pre><p>Join multiple Gauss quadratures together.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/gauss.jl#L74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.legder-Union{Tuple{AbstractMatrix{T}}, Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T" href="#SparseIR.legder-Union{Tuple{AbstractMatrix{T}}, Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T"><code>SparseIR.legder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">legder</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/_specfuncs.jl#L52-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.legendre-Tuple{Any}" href="#SparseIR.legendre-Tuple{Any}"><code>SparseIR.legendre</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">legendre(n[, T])</code></pre><p>Gauss-Legendre quadrature with <code>n</code> points on [-1, 1].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/gauss.jl#L95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.legendre_collocation" href="#SparseIR.legendre_collocation"><code>SparseIR.legendre_collocation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">legendre_collocation(rule, n=length(rule.x))</code></pre><p>Generate collocation matrix from Gauss-Legendre rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/gauss.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.legvander-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer}} where T" href="#SparseIR.legvander-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer}} where T"><code>SparseIR.legvander</code></a> — <span class="docstring-category">Method</span></header><section><div><p>legvander(x, deg)</p><p>Pseudo-Vandermonde matrix of degree <code>deg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/_specfuncs.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.matop!-Union{Tuple{N}, Tuple{T}, Tuple{S}, Tuple{AbstractArray{S, N}, Any, AbstractArray{T, N}, Any, Any}} where {S, T, N}" href="#SparseIR.matop!-Union{Tuple{N}, Tuple{T}, Tuple{S}, Tuple{AbstractArray{S, N}, Any, AbstractArray{T, N}, Any, Any}} where {S, T, N}"><code>SparseIR.matop!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matop!(buffer, mat, arr::AbstractArray, op, dim)</code></pre><p>Apply the operator <code>op</code> to the matrix <code>mat</code> and to the array <code>arr</code> along the first dimension (dim=1) or the last dimension (dim=N).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/sampling.jl#L249-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.matop_along_dim!-Union{Tuple{N}, Tuple{T}, Tuple{Any, Any, AbstractArray{T, N}, Any, Any}} where {T, N}" href="#SparseIR.matop_along_dim!-Union{Tuple{N}, Tuple{T}, Tuple{Any, Any, AbstractArray{T, N}, Any, Any}} where {T, N}"><code>SparseIR.matop_along_dim!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matop_along_dim!(buffer, mat, arr::AbstractArray, dim::Integer, op)</code></pre><p>Apply the operator <code>op</code> to the matrix <code>mat</code> and to the array <code>arr</code> along the dimension <code>dim</code>, writing the result to <code>buffer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/sampling.jl#L224-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.matrices-Tuple{SparseIR.SamplingSVE}" href="#SparseIR.matrices-Tuple{SparseIR.SamplingSVE}"><code>SparseIR.matrices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrices(sve::AbstractSVE)</code></pre><p>SVD problems underlying the SVE.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/sve.jl#L151-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.matrix_from_gauss-Tuple{Any, Any, Any}" href="#SparseIR.matrix_from_gauss-Tuple{Any, Any, Any}"><code>SparseIR.matrix_from_gauss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_from_gauss(kernel, gauss_x, gauss_y)</code></pre><p>Compute matrix for kernel from Gauss rules.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/kernel.jl#L279-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.movedim-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Pair}} where {T, N}" href="#SparseIR.movedim-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Pair}} where {T, N}"><code>SparseIR.movedim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">movedim(arr::AbstractArray, src =&gt; dst)</code></pre><p>Move <code>arr</code>&#39;s dimension at <code>src</code> to <code>dst</code> while keeping the order of the remaining dimensions unchanged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/sampling.jl#L204-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.ngauss" href="#SparseIR.ngauss"><code>SparseIR.ngauss</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ngauss(hints)</code></pre><p>Gauss-Legendre order to use to guarantee accuracy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/kernel.jl#L459-L463">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.nsvals-Tuple{SparseIR.SVEHintsLogistic}" href="#SparseIR.nsvals-Tuple{SparseIR.SVEHintsLogistic}"><code>SparseIR.nsvals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nsvals(hints)</code></pre><p>Upper bound for number of singular values.</p><p>Upper bound on the number of singular values above the given threshold, i.e. where <code>s[l] ≥ ε * first(s)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/kernel.jl#L439-L446">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.phase_stable-Tuple{Any, Any}" href="#SparseIR.phase_stable-Tuple{Any, Any}"><code>SparseIR.phase_stable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phase_stable(poly, wn)</code></pre><p>Phase factor for the piecewise Legendre to Matsubara transform.</p><p>Compute the following phase factor in a stable way:</p><pre><code class="nohighlight hljs">exp.(iπ/2 * wn * cumsum(poly.Δx))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/poly.jl#L501-L509">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.piecewise-Tuple{Any, Vector}" href="#SparseIR.piecewise-Tuple{Any, Vector}"><code>SparseIR.piecewise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">piecewise(rule, edges)</code></pre><p>Piecewise quadrature with the same quadrature rule, but scaled.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/gauss.jl#L62-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.postprocess" href="#SparseIR.postprocess"><code>SparseIR.postprocess</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">postprocess(sve::AbstractSVE, u, s, v, T=nothing)</code></pre><p>Construct the SVE result from the SVD.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/sve.jl#L164-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.quadrature-Tuple{Any, Any}" href="#SparseIR.quadrature-Tuple{Any, Any}"><code>SparseIR.quadrature</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">quadrature(rule, f)</code></pre><p>Approximate <code>f</code>&#39;s integral.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/gauss.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.reseat-Tuple{SparseIR.Rule, Any, Any}" href="#SparseIR.reseat-Tuple{SparseIR.Rule, Any, Any}"><code>SparseIR.reseat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reseat(rule, a, b)</code></pre><p>Reseat quadrature rule to new domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/gauss.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.roots-Tuple{SparseIR.PiecewiseLegendrePoly}" href="#SparseIR.roots-Tuple{SparseIR.PiecewiseLegendrePoly}"><code>SparseIR.roots</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">roots(poly)</code></pre><p>Find all roots of the piecewise polynomial <code>poly</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/poly.jl#L111-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.scale-Tuple{Any, Any}" href="#SparseIR.scale-Tuple{Any, Any}"><code>SparseIR.scale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scale(rule, factor)</code></pre><p>Scale weights by <code>factor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/gauss.jl#L53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.segments_x-Tuple{SparseIR.SVEHintsLogistic}" href="#SparseIR.segments_x-Tuple{SparseIR.SVEHintsLogistic}"><code>SparseIR.segments_x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">segments_x(sve_hints::AbstractSVEHints)</code></pre><p>Segments for piecewise polynomials on the <span>$x$</span> axis.</p><p>List of segments on the <span>$x$</span> axis for the associated piecewise polynomial. Should reflect the approximate position of roots of a high-order singular function in <span>$x$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/kernel.jl#L221-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.segments_y-Tuple{SparseIR.SVEHintsLogistic}" href="#SparseIR.segments_y-Tuple{SparseIR.SVEHintsLogistic}"><code>SparseIR.segments_y</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">segments_y(sve_hints::AbstractSVEHints)</code></pre><p>Segments for piecewise polynomials on the <span>$y$</span> axis.</p><p>List of segments on the <span>$y$</span> axis for the associated piecewise polynomial. Should reflect the approximate position of roots of a high-order singular function in <span>$y$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/kernel.jl#L237-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.shift_xmid-Tuple{Any, Any}" href="#SparseIR.shift_xmid-Tuple{Any, Any}"><code>SparseIR.shift_xmid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shift_xmid(knots, Δx)</code></pre><p>Return midpoint relative to the nearest integer plus a shift.</p><p>Return the midpoints <code>xmid</code> of the segments, as pair <code>(diff, shift)</code>, where shift is in <code>(0, 1, -1)</code> and <code>diff</code> is a float such that <code>xmid == shift + diff</code> to floating point accuracy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/poly.jl#L481-L489">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.significance" href="#SparseIR.significance"><code>SparseIR.significance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">significance(basis::AbstractBasis)</code></pre><p>Return vector <code>σ</code>, where <code>0 ≤ σ[i] ≤ 1</code> is the significance level of the <code>i</code>-th basis function.  If <code>ϵ</code> is the desired accuracy to which to represent a propagator, then any basis function where <code>σ[i] &lt; ϵ</code> can be neglected.</p><p>For the IR basis, we simply have that <code>σ[i] = s[i] / first(s)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/basis.jl#L7-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.split-Tuple{Any, Number}" href="#SparseIR.split-Tuple{Any, Number}"><code>SparseIR.split</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">split(poly, x)</code></pre><p>Split segment.</p><p>Find segment of poly&#39;s domain that covers <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/poly.jl#L127-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.sve_hints" href="#SparseIR.sve_hints"><code>SparseIR.sve_hints</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sve_hints(kernel, ε)</code></pre><p>Provide discretisation hints for the SVE routines.</p><p>Advises the SVE routines of discretisation parameters suitable in tranforming the (infinite) SVE into an (finite) SVD problem.</p><p>See also <a href="#SparseIR.AbstractSVEHints"><code>AbstractSVEHints</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/kernel.jl#L424-L433">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.truncate" href="#SparseIR.truncate"><code>SparseIR.truncate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">truncate(u, s, v, rtol=0, lmax=typemax(Int))</code></pre><p>Truncate singular value expansion.</p><p><strong>Arguments</strong></p><pre><code class="nohighlight hljs">- `u`, `s`, `v`: Thin singular value expansion
- `rtol`: Only singular values satisfying `s[l]/s[1] &gt; rtol` are retained.
- `lmax`: At most the `lmax` most significant singular values are retained.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/sve.jl#L291-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.value-Tuple{MatsubaraFreq, Real}" href="#SparseIR.value-Tuple{MatsubaraFreq, Real}"><code>SparseIR.value</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get value of the Matsubara frequency <code>ω = n*π/β</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/freq.jl#L94-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.valueim-Tuple{MatsubaraFreq, Real}" href="#SparseIR.valueim-Tuple{MatsubaraFreq, Real}"><code>SparseIR.valueim</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get complex value of the Matsubara frequency <code>iω = iπ/β * n</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/freq.jl#L99-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.weight_func" href="#SparseIR.weight_func"><code>SparseIR.weight_func</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">weight_func(kernel, statistics::Statistics)</code></pre><p>Return the weight function for the given statistics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/kernel.jl#L495-L499">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.workarrlength-Tuple{SparseIR.AbstractSampling, AbstractArray}" href="#SparseIR.workarrlength-Tuple{SparseIR.AbstractSampling, AbstractArray}"><code>SparseIR.workarrlength</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">workarrlength(smpl::AbstractSampling, al; dim=1)</code></pre><p>Return length of workarr for <code>fit!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/sampling.jl#L174-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.xrange" href="#SparseIR.xrange"><code>SparseIR.xrange</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">xrange(kernel)</code></pre><p>Return a tuple <span>$(x_\mathrm{min}, x_\mathrm{max})$</span> delimiting the range of allowed <code>x</code> values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/kernel.jl#L166-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.ypower" href="#SparseIR.ypower"><code>SparseIR.ypower</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ypower(kernel)</code></pre><p>Power with which the <span>$y$</span> coordinate scales.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/kernel.jl#L469-L473">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.yrange" href="#SparseIR.yrange"><code>SparseIR.yrange</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">yrange(kernel)</code></pre><p>Return a tuple <span>$(y_\mathrm{min}, y_\mathrm{max})$</span> delimiting the range of allowed <code>y</code> values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/kernel.jl#L176-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.zeta-Tuple{MatsubaraFreq}" href="#SparseIR.zeta-Tuple{MatsubaraFreq}"><code>SparseIR.zeta</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get statistics <code>ζ</code> for Matsubara frequency <code>ω = (2*m+ζ)*π/β</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/freq.jl#L104-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR._LinAlg.givens_lmul-Union{Tuple{T}, Tuple{Tuple{T, T}, Any}} where T" href="#SparseIR._LinAlg.givens_lmul-Union{Tuple{T}, Tuple{Tuple{T, T}, Any}} where T"><code>SparseIR._LinAlg.givens_lmul</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apply Givens rotation to vector:</p><pre><code class="nohighlight hljs">  [ a ]  =  [  c   s ] [ x ]
  [ b ]     [ -s   c ] [ y ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/_linalg.jl#L155-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR._LinAlg.givens_params-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractFloat" href="#SparseIR._LinAlg.givens_params-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractFloat"><code>SparseIR._LinAlg.givens_params</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute Givens rotation <code>R</code> matrix that satisfies:</p><pre><code class="nohighlight hljs">[  c  s ] [ f ]     [ r ]
[ -s  c ] [ g ]  =  [ 0 ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/_linalg.jl#L133-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR._LinAlg.rrqr!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat" href="#SparseIR._LinAlg.rrqr!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>SparseIR._LinAlg.rrqr!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Truncated rank-revealing QR decomposition with full column pivoting.</p><p>Decomposes a <code>(m, n)</code> matrix <code>A</code> into the product:</p><pre><code class="nohighlight hljs">A[:,piv] == Q * R</code></pre><p>where <code>Q</code> is an <code>(m, k)</code> isometric matrix, <code>R</code> is a <code>(k, n)</code> upper triangular matrix, <code>piv</code> is a permutation vector, and <code>k</code> is chosen such that the relative tolerance <code>tol</code> is met in the equality above.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/_linalg.jl#L9-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR._LinAlg.rrqr-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat" href="#SparseIR._LinAlg.rrqr-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>SparseIR._LinAlg.rrqr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Truncated rank-revealing QR decomposition with full column pivoting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/_linalg.jl#L76-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR._LinAlg.svd2x2-Union{Tuple{T}, NTuple{4, T}} where T" href="#SparseIR._LinAlg.svd2x2-Union{Tuple{T}, NTuple{4, T}} where T"><code>SparseIR._LinAlg.svd2x2</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Perform the SVD of an arbitrary two-by-two matrix:</p><pre><code class="nohighlight hljs">  [ a11  a12 ]  =  [  cu  -su ] [ smax     0 ] [  cv   sv ]
  [ a21  a22 ]     [  su   cu ] [    0  smin ] [ -sv   cv ]</code></pre><p>Note that smax and smin can be negative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/_linalg.jl#L218-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR._LinAlg.svd2x2-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:AbstractFloat" href="#SparseIR._LinAlg.svd2x2-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:AbstractFloat"><code>SparseIR._LinAlg.svd2x2</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Perform the SVD of upper triangular two-by-two matrix:</p><pre><code class="nohighlight hljs">  [ f    g   ]  =  [  cu  -su ] [ smax     0 ] [  cv   sv ]
  [ 0    h   ]     [  su   cu ] [    0  smin ] [ -sv   cv ]</code></pre><p>Note that smax and smin can be negative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/_linalg.jl#L167-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR._LinAlg.svd_jacobi!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T" href="#SparseIR._LinAlg.svd_jacobi!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>SparseIR._LinAlg.svd_jacobi!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Singular value decomposition using Jacobi rotations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/_linalg.jl#L284-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR._LinAlg.svd_jacobi-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T" href="#SparseIR._LinAlg.svd_jacobi-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>SparseIR._LinAlg.svd_jacobi</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Singular value decomposition using Jacobi rotations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/_linalg.jl#L304-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR._LinAlg.truncate_qr_result-Union{Tuple{T}, Tuple{LinearAlgebra.QRPivoted{T, S} where S&lt;:AbstractMatrix{T}, Integer}} where T" href="#SparseIR._LinAlg.truncate_qr_result-Union{Tuple{T}, Tuple{LinearAlgebra.QRPivoted{T, S} where S&lt;:AbstractMatrix{T}, Integer}} where T"><code>SparseIR._LinAlg.truncate_qr_result</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Truncate RRQR result low-rank</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/_linalg.jl#L81-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR._LinAlg.tsvd!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat" href="#SparseIR._LinAlg.tsvd!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>SparseIR._LinAlg.tsvd!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Truncated singular value decomposition.</p><p>Decomposes an <code>(m, n)</code> matrix <code>A</code> into the product:</p><pre><code class="nohighlight hljs">A == U * (s .* VT)</code></pre><p>where <code>U</code> is a <code>(m, k)</code> matrix with orthogonal columns, <code>VT</code> is a <code>(k, n)</code> matrix with orthogonal rows and <code>s</code> are the singular values, a set of <code>k</code> nonnegative numbers in non-ascending order.  The SVD is truncated in the sense that singular values below <code>tol</code> are discarded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/_linalg.jl#L94-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR._LinAlg.tsvd-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat" href="#SparseIR._LinAlg.tsvd-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>SparseIR._LinAlg.tsvd</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Truncated singular value decomposition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/c322782e74f7e226cb0b0426083629eb1837d802/src/_linalg.jl#L123-L125">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../public/">« Public</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Monday 8 August 2022 06:41">Monday 8 August 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
