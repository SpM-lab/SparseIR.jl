<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · SparseIR.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>SparseIR.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SpM-lab/SparseIR.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="SparseIR"><a class="docs-heading-anchor" href="#SparseIR">SparseIR</a><a id="SparseIR-1"></a><a class="docs-heading-anchor-permalink" href="#SparseIR" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/SpM-lab/SparseIR.jl">SparseIR</a>.</p><ul><li><a href="#SparseIR.SparseIR"><code>SparseIR.SparseIR</code></a></li><li><a href="#Core.Union-Tuple{Integer}"><code>Core.Union</code></a></li><li><a href="#SparseIR.AbstractKernel"><code>SparseIR.AbstractKernel</code></a></li><li><a href="#SparseIR.AbstractKernel"><code>SparseIR.AbstractKernel</code></a></li><li><a href="#SparseIR.AbstractSVEHints"><code>SparseIR.AbstractSVEHints</code></a></li><li><a href="#SparseIR.AbstractSampling"><code>SparseIR.AbstractSampling</code></a></li><li><a href="#SparseIR.CentrosymmSVE"><code>SparseIR.CentrosymmSVE</code></a></li><li><a href="#SparseIR.CompositeBasisFunction"><code>SparseIR.CompositeBasisFunction</code></a></li><li><a href="#SparseIR.CompositeBasisFunction-Tuple{Real}"><code>SparseIR.CompositeBasisFunction</code></a></li><li><a href="#SparseIR.CompositeBasisFunctionFT"><code>SparseIR.CompositeBasisFunctionFT</code></a></li><li><a href="#SparseIR.CompositeBasisFunctionFT-Tuple{Union{Int64, Vector{Int64}}}"><code>SparseIR.CompositeBasisFunctionFT</code></a></li><li><a href="#SparseIR.DimensionlessBasis"><code>SparseIR.DimensionlessBasis</code></a></li><li><a href="#SparseIR.DimensionlessBasis"><code>SparseIR.DimensionlessBasis</code></a></li><li><a href="#SparseIR.FiniteTempBasis"><code>SparseIR.FiniteTempBasis</code></a></li><li><a href="#SparseIR.FiniteTempBasis"><code>SparseIR.FiniteTempBasis</code></a></li><li><a href="#SparseIR.FiniteTempBasisSet"><code>SparseIR.FiniteTempBasisSet</code></a></li><li><a href="#SparseIR.FiniteTempBasisSet-Tuple{AbstractFloat, AbstractFloat, Any}"><code>SparseIR.FiniteTempBasisSet</code></a></li><li><a href="#SparseIR.LegendreBasis"><code>SparseIR.LegendreBasis</code></a></li><li><a href="#SparseIR.LogisticKernel"><code>SparseIR.LogisticKernel</code></a></li><li><a href="#SparseIR.LogisticKernelOdd"><code>SparseIR.LogisticKernelOdd</code></a></li><li><a href="#SparseIR.MatsubaraConstBasis"><code>SparseIR.MatsubaraConstBasis</code></a></li><li><a href="#SparseIR.MatsubaraSampling"><code>SparseIR.MatsubaraSampling</code></a></li><li><a href="#SparseIR.MatsubaraSampling"><code>SparseIR.MatsubaraSampling</code></a></li><li><a href="#SparseIR.NestedRule"><code>SparseIR.NestedRule</code></a></li><li><a href="#SparseIR.PiecewiseLegendreFT"><code>SparseIR.PiecewiseLegendreFT</code></a></li><li><a href="#SparseIR.PiecewiseLegendrePoly"><code>SparseIR.PiecewiseLegendrePoly</code></a></li><li><a href="#SparseIR.PiecewiseLegendrePolyVector"><code>SparseIR.PiecewiseLegendrePolyVector</code></a></li><li><a href="#SparseIR.PowerModel"><code>SparseIR.PowerModel</code></a></li><li><a href="#SparseIR.ReducedKernel"><code>SparseIR.ReducedKernel</code></a></li><li><a href="#SparseIR.RegularizedBoseKernel"><code>SparseIR.RegularizedBoseKernel</code></a></li><li><a href="#SparseIR.RegularizedBoseKernelOdd"><code>SparseIR.RegularizedBoseKernelOdd</code></a></li><li><a href="#SparseIR.Rule"><code>SparseIR.Rule</code></a></li><li><a href="#SparseIR.SamplingSVE"><code>SparseIR.SamplingSVE</code></a></li><li><a href="#SparseIR.SparsePoleRepresentation"><code>SparseIR.SparsePoleRepresentation</code></a></li><li><a href="#SparseIR.TauSampling"><code>SparseIR.TauSampling</code></a></li><li><a href="#SparseIR.TauSampling"><code>SparseIR.TauSampling</code></a></li><li><a href="#SparseIR._canonicalize!-Tuple{Any, Any}"><code>SparseIR._canonicalize!</code></a></li><li><a href="#SparseIR._choose_accuracy-Tuple{Any, Any}"><code>SparseIR._choose_accuracy</code></a></li><li><a href="#SparseIR._compute_unl_inner-Tuple{SparseIR.PiecewiseLegendrePoly, Any}"><code>SparseIR._compute_unl_inner</code></a></li><li><a href="#SparseIR._get_tnl-Tuple{Any, Any}"><code>SparseIR._get_tnl</code></a></li><li><a href="#SparseIR._phase_stable-Tuple{Any, Any}"><code>SparseIR._phase_stable</code></a></li><li><a href="#SparseIR._shift_xmid-Tuple{Any, Any}"><code>SparseIR._shift_xmid</code></a></li><li><a href="#SparseIR._split-Tuple{Any, Number}"><code>SparseIR._split</code></a></li><li><a href="#SparseIR.check_domain-Tuple{Any, Any, Any}"><code>SparseIR.check_domain</code></a></li><li><a href="#SparseIR.check_reduced_matsubara-Tuple{Integer}"><code>SparseIR.check_reduced_matsubara</code></a></li><li><a href="#SparseIR.compute_sve-Tuple{SparseIR.AbstractKernel}"><code>SparseIR.compute_sve</code></a></li><li><a href="#SparseIR.cond-Tuple{SparseIR.AbstractSampling}"><code>SparseIR.cond</code></a></li><li><a href="#SparseIR.conv_radius-Tuple{SparseIR.AbstractKernel}"><code>SparseIR.conv_radius</code></a></li><li><a href="#SparseIR.default_matsubara_sampling_points-Tuple{SparseIR.AbstractBasis}"><code>SparseIR.default_matsubara_sampling_points</code></a></li><li><a href="#SparseIR.default_omega_sampling_points-Tuple{SparseIR.AbstractBasis}"><code>SparseIR.default_omega_sampling_points</code></a></li><li><a href="#SparseIR.default_tau_sampling_points-Tuple{SparseIR.AbstractBasis}"><code>SparseIR.default_tau_sampling_points</code></a></li><li><a href="#SparseIR.deriv"><code>SparseIR.deriv</code></a></li><li><a href="#SparseIR.eval_matrix-Tuple{Type{TauSampling}, Any, Any}"><code>SparseIR.eval_matrix</code></a></li><li><a href="#SparseIR.evaluate-Tuple{SparseIR.AbstractSampling, Any}"><code>SparseIR.evaluate</code></a></li><li><a href="#SparseIR.findextrema"><code>SparseIR.findextrema</code></a></li><li><a href="#SparseIR.finite_temp_bases"><code>SparseIR.finite_temp_bases</code></a></li><li><a href="#SparseIR.fit-Tuple{SparseIR.AbstractSampling, Any}"><code>SparseIR.fit</code></a></li><li><a href="#SparseIR.from_IR"><code>SparseIR.from_IR</code></a></li><li><a href="#SparseIR.get_symmetrized-Tuple{SparseIR.AbstractKernel, Any}"><code>SparseIR.get_symmetrized</code></a></li><li><a href="#SparseIR.getwmax-Tuple{FiniteTempBasis}"><code>SparseIR.getwmax</code></a></li><li><a href="#SparseIR.giw-Tuple{Any, Integer}"><code>SparseIR.giw</code></a></li><li><a href="#SparseIR.iscentrosymmetric-Tuple{SparseIR.AbstractKernel}"><code>SparseIR.iscentrosymmetric</code></a></li><li><a href="#SparseIR.iswellconditioned-Tuple{DimensionlessBasis}"><code>SparseIR.iswellconditioned</code></a></li><li><a href="#SparseIR.joinrules-Union{Tuple{AbstractArray{SparseIR.Rule{T}, 1}}, Tuple{T}} where T&lt;:AbstractFloat"><code>SparseIR.joinrules</code></a></li><li><a href="#SparseIR.legder"><code>SparseIR.legder</code></a></li><li><a href="#SparseIR.legendre-Tuple{Any}"><code>SparseIR.legendre</code></a></li><li><a href="#SparseIR.legendre_collocation"><code>SparseIR.legendre_collocation</code></a></li><li><a href="#SparseIR.legvander-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Integer}} where {T, N}"><code>SparseIR.legvander</code></a></li><li><a href="#SparseIR.matop-Union{Tuple{N}, Tuple{T}, Tuple{AbstractMatrix, AbstractArray{T, N}}} where {T, N}"><code>SparseIR.matop</code></a></li><li><a href="#SparseIR.matop_along_dim-Union{Tuple{N}, Tuple{T}, Tuple{AbstractMatrix, AbstractArray{T, N}}, Tuple{AbstractMatrix, AbstractArray{T, N}, Any}} where {T, N}"><code>SparseIR.matop_along_dim</code></a></li><li><a href="#SparseIR.matrices-Tuple{SparseIR.SamplingSVE}"><code>SparseIR.matrices</code></a></li><li><a href="#SparseIR.matrix_from_gauss-Tuple{Any, Any, Any}"><code>SparseIR.matrix_from_gauss</code></a></li><li><a href="#SparseIR.movedim-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Pair}} where {T, N}"><code>SparseIR.movedim</code></a></li><li><a href="#SparseIR.ngauss-Tuple{SparseIR.SVEHintsLogistic}"><code>SparseIR.ngauss</code></a></li><li><a href="#SparseIR.nsvals"><code>SparseIR.nsvals</code></a></li><li><a href="#SparseIR.overlap-Union{Tuple{T}, Tuple{SparseIR.PiecewiseLegendrePoly{T}, Any}} where T"><code>SparseIR.overlap</code></a></li><li><a href="#SparseIR.piecewise-Tuple{Any, Vector}"><code>SparseIR.piecewise</code></a></li><li><a href="#SparseIR.postprocess"><code>SparseIR.postprocess</code></a></li><li><a href="#SparseIR.quadrature-Tuple{Any, Any}"><code>SparseIR.quadrature</code></a></li><li><a href="#SparseIR.reseat-Tuple{SparseIR.Rule, Any, Any}"><code>SparseIR.reseat</code></a></li><li><a href="#SparseIR.roots-Tuple{SparseIR.PiecewiseLegendrePoly}"><code>SparseIR.roots</code></a></li><li><a href="#SparseIR.scale-Tuple{Any, Any}"><code>SparseIR.scale</code></a></li><li><a href="#SparseIR.segments_x"><code>SparseIR.segments_x</code></a></li><li><a href="#SparseIR.segments_y"><code>SparseIR.segments_y</code></a></li><li><a href="#SparseIR.sve_hints"><code>SparseIR.sve_hints</code></a></li><li><a href="#SparseIR.to_IR"><code>SparseIR.to_IR</code></a></li><li><a href="#SparseIR.truncate"><code>SparseIR.truncate</code></a></li><li><a href="#SparseIR.weight_func-Tuple{SparseIR.AbstractKernel, SparseIR.Statistics}"><code>SparseIR.weight_func</code></a></li><li><a href="#SparseIR.xrange-Tuple{SparseIR.AbstractKernel}"><code>SparseIR.xrange</code></a></li><li><a href="#SparseIR.ypower-Tuple{SparseIR.AbstractKernel}"><code>SparseIR.ypower</code></a></li><li><a href="#SparseIR.yrange-Tuple{SparseIR.AbstractKernel}"><code>SparseIR.yrange</code></a></li><li><a href="#SparseIR.Λ-Tuple{DimensionlessBasis}"><code>SparseIR.Λ</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="SparseIR.SparseIR" href="#SparseIR.SparseIR"><code>SparseIR.SparseIR</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Intermediate representation (IR) for many-body propagators</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/SparseIR.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Union-Tuple{Integer}" href="#Core.Union-Tuple{Integer}"><code>Core.Union</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(polyFT::PiecewiseLegendreFT)(n)</code></pre><p>Obtain Fourier transform of polynomial for given frequency index <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/poly.jl#L290-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.AbstractKernel" href="#SparseIR.AbstractKernel"><code>SparseIR.AbstractKernel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">(kernel::AbstractKernel)(x, y[, x₊, x₋])</code></pre><p>Evaluate <code>kernel</code> at point <code>(x, y)</code>.</p><p>The parameters <code>x₊</code> and <code>x₋</code>, if given, shall contain the values of <code>x - xₘᵢₙ</code> and <code>xₘₐₓ - x</code>, respectively.  This is useful if either difference is to be formed and cancellation expected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/kernel.jl#L374-L382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.AbstractKernel" href="#SparseIR.AbstractKernel"><code>SparseIR.AbstractKernel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractKernel</code></pre><p>Integral kernel <code>K(x, y)</code>.</p><p>Abstract base type for an integral kernel, i.e. a AbstractFloat binary function <span>$K(x, y)$</span> used in a Fredhold integral equation of the first kind:</p><p class="math-container">\[    u(x) = ∫ K(x, y) v(y) dy\]</p><p>where <span>$x ∈ [x_\mathrm{min}, x_\mathrm{max}]$</span> and  <span>$y ∈ [y_\mathrm{min}, y_\mathrm{max}]$</span>.  For its SVE to exist, the kernel must be square-integrable, for its singular values to decay exponentially, it must be smooth.</p><p>In general, the kernel is applied to a scaled spectral function <span>$ρ&#39;(y)$</span> as:</p><p class="math-container">\[    ∫ K(x, y) ρ&#39;(y) dy,\]</p><p>where <span>$ρ&#39;(y) = w(y) ρ(y)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/kernel.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.AbstractSVEHints" href="#SparseIR.AbstractSVEHints"><code>SparseIR.AbstractSVEHints</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractSVEHints</code></pre><p>Discretization hints for singular value expansion of a given kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/kernel.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.AbstractSampling" href="#SparseIR.AbstractSampling"><code>SparseIR.AbstractSampling</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractSampling</code></pre><p>Abstract class for sparse sampling.</p><p>Encodes the &quot;basis transformation&quot; of a propagator from the truncated IR basis coefficients <code>G_ir[l]</code> to time/frequency sampled on sparse points <code>G(x[i])</code> together with its inverse, a least squares fit:</p><pre><code class="nohighlight hljs">     ________________                   ___________________
    |                |    evaluate     |                   |
    |     Basis      |----------------&gt;|     Value on      |
    |  coefficients  |&lt;----------------|  sampling points  |
    |________________|      fit        |___________________|</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/sampling.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.CentrosymmSVE" href="#SparseIR.CentrosymmSVE"><code>SparseIR.CentrosymmSVE</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CentrosymmSVE &lt;: AbstractSVE</code></pre><p>SVE of centrosymmetric kernel in block-diagonal (even/odd) basis.</p><p>For a centrosymmetric kernel <code>K</code>, i.e., a kernel satisfying: <code>K(x, y) == K(-x, -y)</code>, one can make the following ansatz for the singular functions:</p><pre><code class="nohighlight hljs">u[l](x) = ured[l](x) + sign[l] * ured[l](-x)
v[l](y) = vred[l](y) + sign[l] * ured[l](-y)</code></pre><p>where <code>sign[l]</code> is either <code>+1</code> or <code>-1</code>.  This means that the singular value expansion can be block-diagonalized into an even and an odd part by (anti-)symmetrizing the kernel:</p><pre><code class="nohighlight hljs">K_even = K(x, y) + K(x, -y)
K_odd  = K(x, y) - K(x, -y)</code></pre><p>The <code>l</code>th basis function, restricted to the positive interval, is then the singular function of one of these kernels.  If the kernel generates a Chebyshev system [1], then even and odd basis functions alternate.</p><p>[1]: A. Karlin, Total Positivity (1968).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/sve.jl#L54-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.CompositeBasisFunction" href="#SparseIR.CompositeBasisFunction"><code>SparseIR.CompositeBasisFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Union of several basis functions in the imaginary-time/real-frequency domain domains</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/composite.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.CompositeBasisFunction-Tuple{Real}" href="#SparseIR.CompositeBasisFunction-Tuple{Real}"><code>SparseIR.CompositeBasisFunction</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate basis function at position x</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/composite.jl#L9-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.CompositeBasisFunctionFT" href="#SparseIR.CompositeBasisFunctionFT"><code>SparseIR.CompositeBasisFunctionFT</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Union of several basis functions in the imaginary-frequency domain domains</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/composite.jl#L20-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.CompositeBasisFunctionFT-Tuple{Union{Int64, Vector{Int64}}}" href="#SparseIR.CompositeBasisFunctionFT-Tuple{Union{Int64, Vector{Int64}}}"><code>SparseIR.CompositeBasisFunctionFT</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Evaluate basis function at frequency n</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/composite.jl#L28-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.DimensionlessBasis" href="#SparseIR.DimensionlessBasis"><code>SparseIR.DimensionlessBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DimensionlessBasis(statistics, Λ, ε=nothing; kernel=LogisticKernel(Λ), sve_result=compute_sve(kernel; ε))</code></pre><p>Construct an IR basis suitable for the given <code>statistics</code> and cutoff <code>Λ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/basis.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.DimensionlessBasis" href="#SparseIR.DimensionlessBasis"><code>SparseIR.DimensionlessBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DimensionlessBasis &lt;: AbstractBasis</code></pre><p>Intermediate representation (IR) basis in reduced variables.</p><p>For a continuation kernel <code>K</code> from real frequencies, <code>ω ∈ [-ωmax, ωmax]</code>, to imaginary time, <code>τ ∈ [0, β]</code>, this class stores the truncated singular value expansion or IR basis:</p><pre><code class="nohighlight hljs">K(x, y) ≈ sum(u[l](x) * s[l] * v[l](y) for l in range(L))</code></pre><p>The functions are given in reduced variables, <code>x = 2τ/β - 1</code> and <code>y = ω/ωmax</code>, which scales both sides to the interval <code>[-1, 1]</code>.  The kernel then only depends on a cutoff parameter <code>Λ = β * ωmax</code>.</p><p><strong>Examples</strong></p><p>The following example code assumes the spectral function is a single pole at <code>x = 0.2</code>. We first compute an IR basis suitable for fermions and <code>β*W ≤ 42</code>. Then we get G(iw) on the first few Matsubara frequencies:</p><pre><code class="language-julia-repl hljs">julia&gt; using SparseIR

julia&gt; basis = DimensionlessBasis(fermion, 42);

julia&gt; gl = basis.s .* basis.v(0.2);

julia&gt; giw = transpose(basis.uhat([1, 3, 5, 7])) * gl</code></pre><p><strong>Fields</strong></p><ul><li><p><code>u::PiecewiseLegendrePolyVector</code>: Set of IR basis functions on the reduced imaginary time (<code>x</code>) axis. These functions are stored as piecewise Legendre polynomials.</p><p>To obtain the value of all basis functions at a point or a array of points <code>x</code>, you can call the function <code>u(x)</code>.  To obtain a single basis function, a slice or a subset <code>l</code>, you can use <code>u[l]</code>.</p></li><li><p><code>uhat::PiecewiseLegendreFTVector</code>: Set of IR basis functions on the Matsubara frequency (<code>wn</code>) axis.</p></li></ul><p>These objects are stored as a set of Bessel functions.</p><p>To obtain the value of all basis functions at a Matsubara frequency   or a array of points <code>wn</code>, you can call the function <code>uhat(wn)</code>.   Note that we expect reduced frequencies, which are simply even/odd   numbers for bosonic/fermionic objects. To obtain a single basis   function, a slice or a subset <code>l</code>, you can use <code>uhat[l]</code>.</p><ul><li><p><code>s</code>: Vector of singular values of the continuation kernel</p></li><li><p><code>v::PiecewiseLegendrePolyVector</code>: Set of IR basis functions on the reduced real frequency (<code>y</code>) axis.</p></li></ul><p>These functions are stored as piecewise Legendre polynomials.</p><p>To obtain the value of all basis functions at a point or a array of   points <code>y</code>, you can call the function <code>v(y)</code>.  To obtain a single   basis function, a slice or a subset <code>l</code>, you can use <code>v[l]</code>.</p><p>See also <a href="#SparseIR.FiniteTempBasis"><code>FiniteTempBasis</code></a> for a basis directly in time/frequency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/basis.jl#L7-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.FiniteTempBasis" href="#SparseIR.FiniteTempBasis"><code>SparseIR.FiniteTempBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FiniteTempBasis(statistics, β, wmax, ε=nothing; kernel=LogisticKernel(β * wmax), sve_result=compute_sve(kernel; ε))</code></pre><p>Construct a finite temperature basis suitable for the given <code>statistics</code> and cutoffs <code>β</code> and <code>wmax</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/basis.jl#L189-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.FiniteTempBasis" href="#SparseIR.FiniteTempBasis"><code>SparseIR.FiniteTempBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FiniteTempBasis &lt;: AbstractBasis</code></pre><p>Intermediate representation (IR) basis for given temperature.</p><p>For a continuation kernel <code>K</code> from real frequencies, <code>ω ∈ [-ωmax, ωmax]</code>, to imaginary time, <code>τ ∈ [0, beta]</code>, this class stores the truncated singular value expansion or IR basis:</p><pre><code class="nohighlight hljs">K(τ, ω) ≈ sum(u[l](τ) * s[l] * v[l](ω) for l in 1:L)</code></pre><p>This basis is inferred from a reduced form by appropriate scaling of the variables.</p><p><strong>Examples</strong></p><p>The following example code assumes the spectral function is a single pole at <code>ω = 2.5</code>. We first compute an IR basis suitable for fermions and <code>β = 10</code>, <code>W ≤ 4.2</code>. Then we get G(iw) on the first few Matsubara frequencies:</p><pre><code class="language-julia-repl hljs">julia&gt; using SparseIR

julia&gt; basis = FiniteTempBasis(fermion, 42, 4.2);

julia&gt; gl = basis.s .* basis.v(2.5);

julia&gt; giw = transpose(basis.uhat([1, 3, 5, 7])) * gl</code></pre><p><strong>Fields</strong></p><ul><li><p><code>u::PiecewiseLegendrePolyVector</code>: Set of IR basis functions on the imaginary time (<code>tau</code>) axis. These functions are stored as piecewise Legendre polynomials.</p><p>To obtain the value of all basis functions at a point or a array of points <code>x</code>, you can call the function <code>u(x)</code>.  To obtain a single basis function, a slice or a subset <code>l</code>, you can use <code>u[l]</code>.</p></li><li><p><code>uhat::PiecewiseLegendreFT</code>: Set of IR basis functions on the Matsubara frequency (<code>wn</code>) axis. These objects are stored as a set of Bessel functions.</p><p>To obtain the value of all basis functions at a Matsubara frequency or a array of points <code>wn</code>, you can call the function <code>uhat(wn)</code>. Note that we expect reduced frequencies, which are simply even/odd numbers for bosonic/fermionic objects. To obtain a single basis function, a slice or a subset <code>l</code>, you can use <code>uhat[l]</code>.</p></li><li><p><code>s</code>: Vector of singular values of the continuation kernel</p></li><li><p><code>v::PiecewiseLegendrePoly</code>: Set of IR basis functions on the real frequency (<code>w</code>) axis. These functions are stored as piecewise Legendre polynomials.</p><p>To obtain the value of all basis functions at a point or a array of points <code>w</code>, you can call the function <code>v(w)</code>.  To obtain a single basis function, a slice or a subset <code>l</code>, you can use <code>v[l]</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/basis.jl#L111-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.FiniteTempBasisSet" href="#SparseIR.FiniteTempBasisSet"><code>SparseIR.FiniteTempBasisSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FiniteTempBasisSet</code></pre><p>Class for holding IR bases and sparse-sampling objects.</p><p>An object of this class holds IR bases for fermions and bosons and associated sparse-sampling objects.</p><p><strong>Fields</strong></p><ul><li>basis_f::FiniteTempBasis: Fermion basis</li><li>basis_b::FiniteTempBasis: Boson basis</li><li>beta::Float64: Inverse temperature</li><li>wmax::Float64: Cut-off frequency</li><li>tau::Vector{Float64}: Sampling points in the imaginary-time domain</li><li>wn_f::Vector{Int}: Sampling fermionic frequencies</li><li>wn_b::Vector{Int}: Sampling bosonic frequencies</li><li>smpl<em>tau</em>f::TauSampling: Sparse sampling for tau &amp; fermion</li><li>smpl<em>tau</em>b::TauSampling: Sparse sampling for tau &amp; boson</li><li>smpl<em>wn</em>f::MatsubaraSampling: Sparse sampling for Matsubara frequency &amp; fermion</li><li>smpl<em>wn</em>b::MatsubaraSampling: Sparse sampling for Matsubara frequency &amp; boson</li><li>sve_result::Tuple{PiecewiseLegendrePoly,Vector{Float64},PiecewiseLegendrePoly}: Results of SVE</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/basis_set.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.FiniteTempBasisSet-Tuple{AbstractFloat, AbstractFloat, Any}" href="#SparseIR.FiniteTempBasisSet-Tuple{AbstractFloat, AbstractFloat, Any}"><code>SparseIR.FiniteTempBasisSet</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FiniteTempBasisSet(β, wmax, ε; sve_result=compute_sve(LogisticKernel(β * wmax); ε))</code></pre><p>Create basis sets for fermion and boson and associated sampling objects. Fermion and bosonic bases are constructed by SVE of the logistic kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/basis_set.jl#L32-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.LegendreBasis" href="#SparseIR.LegendreBasis"><code>SparseIR.LegendreBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Legendre basis</p><p>In the original paper [L. Boehnke et al., PRB 84, 075145 (2011)], they used:</p><pre><code class="nohighlight hljs">G(\tau) = \sum_{l=0} \sqrt{2l+1} P_l[x(\tau)] G_l/beta,</code></pre><p>where P_l[x] is the <span>$l$</span>-th Legendre polynomial.</p><p>In this class, the basis functions are defined by</p><pre><code class="nohighlight hljs">U_l(\tau) \equiv c_l (\sqrt{2l+1}/beta) * P_l[x(\tau)],</code></pre><p>where c<em>l are additional l-depenent constant factors. By default, we take c</em>l = 1, which reduces to the original definition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/augment.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.LogisticKernel" href="#SparseIR.LogisticKernel"><code>SparseIR.LogisticKernel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LogisticKernel &lt;: AbstractKernel</code></pre><p>Fermionic/bosonic analytical continuation kernel.</p><p>In dimensionless variables <span>$x = 2 τ/β - 1$</span>, <span>$y = β ω/Λ$</span>, the integral kernel is a function on <span>$[-1, 1] × [-1, 1]$</span>:</p><p class="math-container">\[    K(x, y) = \frac{e^{-Λ y (x + 1) / 2}}{1 + e^{-Λ y}}\]</p><p>LogisticKernel is a fermionic analytic continuation kernel. Nevertheless, one can model the <span>$τ$</span> dependence of a bosonic correlation function as follows:</p><p class="math-container">\[    ∫ \frac{e^{-Λ y (x + 1) / 2}}{1 - e^{-Λ y}} ρ(y) dy = ∫ K(x, y) ρ&#39;(y) dy,\]</p><p>with</p><p class="math-container">\[    ρ&#39;(y) = w(y) ρ(y),\]</p><p>where the weight function is given by</p><p class="math-container">\[    w(y) = \frac{1}{\tanh(Λ y/2)}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/kernel.jl#L24-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.LogisticKernelOdd" href="#SparseIR.LogisticKernelOdd"><code>SparseIR.LogisticKernelOdd</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LogisticKernelOdd &lt;: AbstractReducedKernel</code></pre><p>Fermionic analytical continuation kernel, odd.</p><p>In dimensionless variables <span>$x = 2τ/β - 1$</span>, <span>$y = βω/Λ$</span>, the fermionic integral kernel is a function on <span>$[-1, 1] × [-1, 1]$</span>:</p><p class="math-container">\[    K(x, y) = -\frac{\sinh(Λ x y / 2)}{\cosh(Λ y / 2)}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/kernel.jl#L123-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.MatsubaraConstBasis" href="#SparseIR.MatsubaraConstBasis"><code>SparseIR.MatsubaraConstBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Constant term in matsubara-frequency domain</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/augment.jl#L73-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.MatsubaraSampling" href="#SparseIR.MatsubaraSampling"><code>SparseIR.MatsubaraSampling</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MatsubaraSampling(basis, sampling_points)</code></pre><p>Construct a <code>MatsubaraSampling</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/sampling.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.MatsubaraSampling" href="#SparseIR.MatsubaraSampling"><code>SparseIR.MatsubaraSampling</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MatsubaraSampling &lt;: AbstractSampling</code></pre><p>Sparse sampling in Matsubara frequencies.</p><p>Allows the transformation between the IR basis and a set of sampling points in (scaled/unscaled) imaginary frequencies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/sampling.jl#L57-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.NestedRule" href="#SparseIR.NestedRule"><code>SparseIR.NestedRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NestedRule{T}</code></pre><p>Nested quadrature rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/gauss.jl#L112-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.PiecewiseLegendreFT" href="#SparseIR.PiecewiseLegendreFT"><code>SparseIR.PiecewiseLegendreFT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PiecewiseLegendreFT &lt;: Function</code></pre><p>Fourier transform of a piecewise Legendre polynomial.</p><p>For a given frequency index <code>n</code>, the Fourier transform of the Legendre function is defined as:</p><pre><code class="nohighlight hljs">    p̂(n) == ∫ dx exp(im * π * n * x / (xmax - xmin)) p(x)</code></pre><p>The polynomial is continued either periodically (<code>freq=:even</code>), in which case <code>n</code> must be even, or antiperiodically (<code>freq=:odd</code>), in which case <code>n</code> must be odd.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/poly.jl#L244-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.PiecewiseLegendrePoly" href="#SparseIR.PiecewiseLegendrePoly"><code>SparseIR.PiecewiseLegendrePoly</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PiecewiseLegendrePoly &lt;: Function</code></pre><p>Piecewise Legendre polynomial.</p><p>Models a function on the interval <span>$[xmin, xmax]$</span> as a set of segments on the intervals <span>$S[i] = [a[i], a[i+1]]$</span>, where on each interval the function is expanded in scaled Legendre polynomials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/poly.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.PiecewiseLegendrePolyVector" href="#SparseIR.PiecewiseLegendrePolyVector"><code>SparseIR.PiecewiseLegendrePolyVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PiecewiseLegendrePolyVector{T}</code></pre><p>Alias for <code>Vector{PiecewiseLegendrePoly{T}}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/poly.jl#L153-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.PowerModel" href="#SparseIR.PowerModel"><code>SparseIR.PowerModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PowerModel</code></pre><p>Model from a high-frequency series expansion::</p><pre><code class="nohighlight hljs">A(iω) == sum(A[n] / (iω)^(n+1) for n in 1:N)</code></pre><p>where <span>$iω == i * π/2 * wn$</span> is a reduced imaginary frequency, i.e., <span>$wn$</span> is an odd/even number for fermionic/bosonic frequencies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/poly.jl#L225-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.ReducedKernel" href="#SparseIR.ReducedKernel"><code>SparseIR.ReducedKernel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReducedKernel</code></pre><p>Restriction of centrosymmetric kernel to positive interval.</p><p>For a kernel <span>$K$</span> on <span>$[-1, 1] × [-1, 1]$</span> that is centrosymmetric, i.e. <span>$K(x, y) = K(-x, -y)$</span>, it is straight-forward to show that the left/right singular vectors can be chosen as either odd or even functions.</p><p>Consequentially, they are singular functions of a reduced kernel <span>$K_\mathrm{red}$</span> on <span>$[0, 1] × [0, 1]$</span> that is given as either:</p><p class="math-container">\[    K_\mathrm{red}(x, y) = K(x, y) \pm K(x, -y)\]</p><p>This kernel is what this class represents.  The full singular functions can be reconstructed by (anti-)symmetrically continuing them to the negative axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/kernel.jl#L100-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.RegularizedBoseKernel" href="#SparseIR.RegularizedBoseKernel"><code>SparseIR.RegularizedBoseKernel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RegularizedBoseKernel &lt;: AbstractKernel</code></pre><p>Regularized bosonic analytical continuation kernel.</p><p>In dimensionless variables <span>$x = 2 τ/β - 1$</span>, <span>$y = β ω/Λ$</span>, the fermionic integral kernel is a function on <span>$[-1, 1] × [-1, 1]$</span>:</p><p class="math-container">\[    K(x, y) = y \frac{e^{-Λ y (x + 1) / 2}}{e^{-Λ y} - 1}\]</p><p>Care has to be taken in evaluating this expression around <span>$y = 0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/kernel.jl#L57-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.RegularizedBoseKernelOdd" href="#SparseIR.RegularizedBoseKernelOdd"><code>SparseIR.RegularizedBoseKernelOdd</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RegularizedBoseKernelOdd &lt;: AbstractReducedKernel</code></pre><p>Bosonic analytical continuation kernel, odd.</p><p>In dimensionless variables <span>$x = 2 τ / β - 1$</span>, <span>$y = β ω / Λ$</span>, the fermionic integral kernel is a function on <span>$[-1, 1] × [-1, 1]$</span>:</p><p class="math-container">\[    K(x, y) = -y \frac{\sinh(Λ x y / 2)}{\sinh(Λ y / 2)}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/kernel.jl#L145-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.Rule" href="#SparseIR.Rule"><code>SparseIR.Rule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Rule{T&lt;:AbstractFloat}</code></pre><p>Quadrature rule.</p><p>Approximation of an integral over <code>[a, b]</code> by a sum over discrete points <code>x</code> with weights <code>w</code>:</p><p class="math-container">\[    ∫ f(x) ω(x) dx ≈ ∑_i f(x_i) w_i\]</p><p>where we generally have superexponential convergence for smooth <span>$f(x)$</span> in  the number of quadrature points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/gauss.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.SamplingSVE" href="#SparseIR.SamplingSVE"><code>SparseIR.SamplingSVE</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SamplingSVE &lt;: AbstractSVE</code></pre><p>SVE to SVD translation by sampling technique [1].</p><p>Maps the singular value expansion (SVE) of a kernel <code>kernel</code> onto the singular value decomposition of a matrix <code>A</code>.  This is achieved by choosing two sets of Gauss quadrature rules: <code>(x, wx)</code> and <code>(y, wy)</code> and approximating the integrals in the SVE equations by finite sums.  This implies that the singular values of the SVE are well-approximated by the singular values of the following matrix:</p><pre><code class="nohighlight hljs">A[i, j] = √(wx[i]) * K(x[i], y[j]) * √(wy[j])</code></pre><p>and the values of the singular functions at the Gauss sampling points can be reconstructed from the singular vectors <code>u</code> and <code>v</code> as follows:</p><pre><code class="nohighlight hljs">u[l,i] ≈ √(wx[i]) u[l](x[i])
v[l,j] ≈ √(wy[j]) u[l](y[j])</code></pre><p>[1] P. Hansen, Discrete Inverse Problems, Ch. 3.1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/sve.jl#L3-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.SparsePoleRepresentation" href="#SparseIR.SparsePoleRepresentation"><code>SparseIR.SparsePoleRepresentation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Sparse pole representation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/spr.jl#L40-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.TauSampling" href="#SparseIR.TauSampling"><code>SparseIR.TauSampling</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TauSampling(basis, sampling_points)</code></pre><p>Construct a <code>TauSampling</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/sampling.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.TauSampling" href="#SparseIR.TauSampling"><code>SparseIR.TauSampling</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TauSampling &lt;: AbstractSampling</code></pre><p>Sparse sampling in imaginary time.</p><p>Allows the transformation between the IR basis and a set of sampling points in (scaled/unscaled) imaginary time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/sampling.jl#L26-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR._canonicalize!-Tuple{Any, Any}" href="#SparseIR._canonicalize!-Tuple{Any, Any}"><code>SparseIR._canonicalize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">canonicalize!(u, v)</code></pre><p>Canonicalize basis.</p><p>Each SVD <code>(u[l], v[l])</code> pair is unique only up to a global phase, which may differ from implementation to implementation and also platform.  We fix that gauge by demanding <code>u[l](1) &gt; 0</code>.  This ensures a diffeomorphic connection to the Legendre polynomials as <code>Λ → 0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/sve.jl#L288-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR._choose_accuracy-Tuple{Any, Any}" href="#SparseIR._choose_accuracy-Tuple{Any, Any}"><code>SparseIR._choose_accuracy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">choose_accuracy(ε, Twork)</code></pre><p>Choose work type and accuracy based on specs and defaults</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/sve.jl#L254-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR._compute_unl_inner-Tuple{SparseIR.PiecewiseLegendrePoly, Any}" href="#SparseIR._compute_unl_inner-Tuple{SparseIR.PiecewiseLegendrePoly, Any}"><code>SparseIR._compute_unl_inner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_compute_unl_inner(poly, wn)</code></pre><p>Compute piecewise Legendre to Matsubara transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/poly.jl#L465-L469">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR._get_tnl-Tuple{Any, Any}" href="#SparseIR._get_tnl-Tuple{Any, Any}"><code>SparseIR._get_tnl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_get_tnl(l, w)</code></pre><p>Fourier integral of the <code>l</code>-th Legendre polynomial::</p><pre><code class="nohighlight hljs">Tₗ(ω) == ∫ dx exp(iωx) Pₗ(x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/poly.jl#L486-L492">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR._phase_stable-Tuple{Any, Any}" href="#SparseIR._phase_stable-Tuple{Any, Any}"><code>SparseIR._phase_stable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_phase_stable(poly, wn)</code></pre><p>Phase factor for the piecewise Legendre to Matsubara transform.</p><p>Compute the following phase factor in a stable way:</p><pre><code class="nohighlight hljs">exp.(iπ/2 * wn * cumsum(poly.Δx))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/poly.jl#L521-L529">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR._shift_xmid-Tuple{Any, Any}" href="#SparseIR._shift_xmid-Tuple{Any, Any}"><code>SparseIR._shift_xmid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_shift_xmid(knots, Δx)</code></pre><p>Return midpoint relative to the nearest integer plus a shift.</p><p>Return the midpoints <code>xmid</code> of the segments, as pair <code>(diff, shift)</code>, where shift is in <code>(0, 1, -1)</code> and <code>diff</code> is a float such that <code>xmid == shift + diff</code> to floating point accuracy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/poly.jl#L501-L509">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR._split-Tuple{Any, Number}" href="#SparseIR._split-Tuple{Any, Number}"><code>SparseIR._split</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_split(poly, x)</code></pre><p>Split segment.</p><p>Find segment of poly&#39;s domain that covers <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/poly.jl#L127-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.check_domain-Tuple{Any, Any, Any}" href="#SparseIR.check_domain-Tuple{Any, Any, Any}"><code>SparseIR.check_domain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_domain(kernel, x, y)</code></pre><p>Check that <code>(x, y)</code> lies within <code>kernel</code>&#39;s domain and return it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/kernel.jl#L299-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.check_reduced_matsubara-Tuple{Integer}" href="#SparseIR.check_reduced_matsubara-Tuple{Integer}"><code>SparseIR.check_reduced_matsubara</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_reduced_matsubara(n[, ζ])</code></pre><p>Checks that <code>n</code> is a reduced Matsubara frequency.</p><p>Check that the argument is a reduced Matsubara frequency, which is an integer obtained by scaling the freqency <code>ω[n]</code> as follows:</p><pre><code class="nohighlight hljs">β / π * ω[n] == 2n + ζ</code></pre><p>Note that this means that instead of a fermionic frequency (<code>ζ == 1</code>), we expect an odd integer, while for a bosonic frequency (<code>ζ == 0</code>), we expect an even one.  If <code>ζ</code> is omitted, any one is fine.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/poly.jl#L442-L455">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.compute_sve-Tuple{SparseIR.AbstractKernel}" href="#SparseIR.compute_sve-Tuple{SparseIR.AbstractKernel}"><code>SparseIR.compute_sve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_sve(kernel; 
    ε=nothing, n_sv=typemax(Int), n_gauss=nothing, T=Float64, Twork=nothing,
    sve_strat=iscentrosymmetric(kernel) ? CentrosymmSVE : SamplingSVE,
    svd_strat=nothing)</code></pre><p>Perform truncated singular value expansion of a kernel.</p><p>Perform a truncated singular value expansion (SVE) of an integral kernel <code>kernel : [xmin, xmax] x [ymin, ymax] -&gt; ℝ</code>:</p><pre><code class="nohighlight hljs">kernel(x, y) == sum(s[l] * u[l](x) * v[l](y) for l in (1, 2, 3, ...)),</code></pre><p>where <code>s[l]</code> are the singular values, which are ordered in non-increasing fashion, <code>u[l](x)</code> are the left singular functions, which form an orthonormal system on <code>[xmin, xmax]</code>, and <code>v[l](y)</code> are the right singular functions, which form an orthonormal system on <code>[ymin, ymax]</code>.</p><p>The SVE is mapped onto the singular value decomposition (SVD) of a matrix by expanding the kernel in piecewise Legendre polynomials (by default by using a collocation).</p><p><strong>Arguments</strong></p><ul><li><code>eps::AbstractFloat</code>:  Relative cutoff for the singular values.</li><li><code>n_sv::Integer</code>: Maximum basis size. If given, only at most the <code>n_sv</code> most</li></ul><p>significant singular values and associated singular functions are returned.</p><ul><li><code>n_gauss::Integer</code>: Order of Legendre polynomials. Defaults to hinted value</li></ul><p>by the kernel.</p><ul><li><code>T</code>: Data type of the result.</li><li><code>Twork</code>: Working data type. Defaults to a data type with</li></ul><p>machine epsilon of at least <code>eps^2</code>, or otherwise most accurate data type available.</p><ul><li><code>sve_strat</code>: SVE to SVD translation strategy. Defaults to SamplingSVE.</li><li><code>svd_strat</code>: SVD solver. Defaults to fast (ID/RRQR) based solution </li></ul><p>when accuracy goals are moderate, and more accurate Jacobi-based  algorithm otherwise.</p><p><strong>Return value</strong></p><p>Return tuple <code>(u, s, v)</code>, where:</p><ul><li><code>u::PiecewiseLegendrePoly</code>: the left singular functions</li><li><code>s::Vector</code>: singular values</li><li><code>v::PiecewiseLegendrePoly</code>: the right singular functions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/sve.jl#L94-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.cond-Tuple{SparseIR.AbstractSampling}" href="#SparseIR.cond-Tuple{SparseIR.AbstractSampling}"><code>SparseIR.cond</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cond(sampling)</code></pre><p>Condition number of the fitting problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/sampling.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.conv_radius-Tuple{SparseIR.AbstractKernel}" href="#SparseIR.conv_radius-Tuple{SparseIR.AbstractKernel}"><code>SparseIR.conv_radius</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conv_radius(kernel)</code></pre><p>Convergence radius of the Matsubara basis asymptotic model.</p><p>For improved relative numerical accuracy, the IR basis functions on the Matsubara axis <code>uhat(basis, n)</code> can be evaluated from an asymptotic expression for <code>abs(n) &gt; conv_radius</code>.  If <code>isinf(conv_radius)</code>, then  the asymptotics are unused (the default).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/kernel.jl#L485-L494">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.default_matsubara_sampling_points-Tuple{SparseIR.AbstractBasis}" href="#SparseIR.default_matsubara_sampling_points-Tuple{SparseIR.AbstractBasis}"><code>SparseIR.default_matsubara_sampling_points</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_default_matsubara_sampling_points(basis; mitigate=true)</code></pre><p>Default sampling points on the imaginary frequency axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/basis.jl#L277-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.default_omega_sampling_points-Tuple{SparseIR.AbstractBasis}" href="#SparseIR.default_omega_sampling_points-Tuple{SparseIR.AbstractBasis}"><code>SparseIR.default_omega_sampling_points</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_omega_sampling_points(basis)</code></pre><p>Default sampling points on the real-frequency axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/basis.jl#L286-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.default_tau_sampling_points-Tuple{SparseIR.AbstractBasis}" href="#SparseIR.default_tau_sampling_points-Tuple{SparseIR.AbstractBasis}"><code>SparseIR.default_tau_sampling_points</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_tau_sampling_points(basis)</code></pre><p>Default sampling points on the imaginary time/<code>x</code> axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/basis.jl#L270-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.deriv" href="#SparseIR.deriv"><code>SparseIR.deriv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">deriv(poly, n=1)</code></pre><p>Get polynomial for the n&#39;th derivative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/poly.jl#L98-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.eval_matrix-Tuple{Type{TauSampling}, Any, Any}" href="#SparseIR.eval_matrix-Tuple{Type{TauSampling}, Any, Any}"><code>SparseIR.eval_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_matrix(T, basis, x)</code></pre><p>Return evaluation matrix from coefficients to sampling points. <code>T &lt;: AbstractSampling</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/sampling.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.evaluate-Tuple{SparseIR.AbstractSampling, Any}" href="#SparseIR.evaluate-Tuple{SparseIR.AbstractSampling, Any}"><code>SparseIR.evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evaluate(sampling, al)</code></pre><p>Evaluate the basis coefficients at the sparse sampling points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/sampling.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.findextrema" href="#SparseIR.findextrema"><code>SparseIR.findextrema</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">findextrema(polyFT::PiecewiseLegendreFT, part=nothing, grid=_DEFAULT_GRID)</code></pre><p>Obtain extrema of fourier-transformed polynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/poly.jl#L334-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.finite_temp_bases" href="#SparseIR.finite_temp_bases"><code>SparseIR.finite_temp_bases</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">finite_temp_bases(β, wmax, ε, sve_result=compute_sve(LogisticKernel(β * wmax); ε))</code></pre><p>Construct FiniteTempBasis objects for fermion and bosons using the same LogisticKernel instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/basis.jl#L256-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.fit-Tuple{SparseIR.AbstractSampling, Any}" href="#SparseIR.fit-Tuple{SparseIR.AbstractSampling, Any}"><code>SparseIR.fit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit(sampling, al)</code></pre><p>Fit basis coefficients from the sparse sampling points</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/sampling.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.from_IR" href="#SparseIR.from_IR"><code>SparseIR.from_IR</code></a> — <span class="docstring-category">Function</span></header><section><div><p>From IR to SPR</p><p>gl:     Expansion coefficients in IR</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/spr.jl#L89-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.get_symmetrized-Tuple{SparseIR.AbstractKernel, Any}" href="#SparseIR.get_symmetrized-Tuple{SparseIR.AbstractKernel, Any}"><code>SparseIR.get_symmetrized</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_symmetrized(kernel, sign)</code></pre><p>Construct a symmetrized version of <code>kernel</code>, i.e. <code>kernel(x, y) + sign * kernel(x, -y)</code>.</p><div class="admonition is-warning"><header class="admonition-header">Beware!</header><div class="admonition-body"><p>By default, this returns a simple wrapper over the current instance which naively performs the sum.  You may want to override this to avoid cancellation.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/kernel.jl#L321-L331">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.getwmax-Tuple{FiniteTempBasis}" href="#SparseIR.getwmax-Tuple{FiniteTempBasis}"><code>SparseIR.getwmax</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getwmax(basis::FiniteTempBasis)</code></pre><p>Real frequency cutoff.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/basis.jl#L249-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.giw-Tuple{Any, Integer}" href="#SparseIR.giw-Tuple{Any, Integer}"><code>SparseIR.giw</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">giw(polyFT, wn)</code></pre><p>Return model Green&#39;s function for reduced frequencies</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/poly.jl#L310-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.iscentrosymmetric-Tuple{SparseIR.AbstractKernel}" href="#SparseIR.iscentrosymmetric-Tuple{SparseIR.AbstractKernel}"><code>SparseIR.iscentrosymmetric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_centrosymmetric(kernel)</code></pre><p>Return <code>true</code> if <code>kernel(x, y) == kernel(-x, -y)</code> for all values of <code>x</code> and <code>y</code>  in range. This allows the kernel to be block-diagonalized, speeding up the singular value expansion by a factor of 4.  Defaults to <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/kernel.jl#L361-L368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.iswellconditioned-Tuple{DimensionlessBasis}" href="#SparseIR.iswellconditioned-Tuple{DimensionlessBasis}"><code>SparseIR.iswellconditioned</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iswellconditioned(basis)</code></pre><p>Return <code>true</code> if the sampling is expected to be well-conditioned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/basis.jl#L233-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.joinrules-Union{Tuple{AbstractArray{SparseIR.Rule{T}, 1}}, Tuple{T}} where T&lt;:AbstractFloat" href="#SparseIR.joinrules-Union{Tuple{AbstractArray{SparseIR.Rule{T}, 1}}, Tuple{T}} where T&lt;:AbstractFloat"><code>SparseIR.joinrules</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">joinrules(rules)</code></pre><p>Join multiple Gauss quadratures together.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/gauss.jl#L70-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.legder" href="#SparseIR.legder"><code>SparseIR.legder</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">legder</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/_specfuncs.jl#L76-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.legendre-Tuple{Any}" href="#SparseIR.legendre-Tuple{Any}"><code>SparseIR.legendre</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">legendre(n[, T])</code></pre><p>Gauss-Legendre quadrature with <code>n</code> points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/gauss.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.legendre_collocation" href="#SparseIR.legendre_collocation"><code>SparseIR.legendre_collocation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">legendre_collocation(rule, n=length(rule.x))</code></pre><p>Generate collocation matrix from Gauss-Legendre rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/gauss.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.legvander-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Integer}} where {T, N}" href="#SparseIR.legvander-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Integer}} where {T, N}"><code>SparseIR.legvander</code></a> — <span class="docstring-category">Method</span></header><section><div><p>legvander(x, deg)</p><p>Pseudo-Vandermonde matrix of degree <code>deg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/_specfuncs.jl#L47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.matop-Union{Tuple{N}, Tuple{T}, Tuple{AbstractMatrix, AbstractArray{T, N}}} where {T, N}" href="#SparseIR.matop-Union{Tuple{N}, Tuple{T}, Tuple{AbstractMatrix, AbstractArray{T, N}}} where {T, N}"><code>SparseIR.matop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matop(mat::AbstractMatrix, arr::AbstractArray; op=*)</code></pre><p>Apply the operator <code>op</code> to the matrix <code>mat</code> and to the array <code>arr</code> along the first dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/sampling.jl#L141-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.matop_along_dim-Union{Tuple{N}, Tuple{T}, Tuple{AbstractMatrix, AbstractArray{T, N}}, Tuple{AbstractMatrix, AbstractArray{T, N}, Any}} where {T, N}" href="#SparseIR.matop_along_dim-Union{Tuple{N}, Tuple{T}, Tuple{AbstractMatrix, AbstractArray{T, N}}, Tuple{AbstractMatrix, AbstractArray{T, N}, Any}} where {T, N}"><code>SparseIR.matop_along_dim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matop_along_dim(mat::AbstractMatrix, arr::AbstractArray, dim::Integer; op=*)</code></pre><p>Apply the operator <code>op</code> to the matrix <code>mat</code> and to the array <code>arr</code> along the dimension <code>dim</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/sampling.jl#L126-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.matrices-Tuple{SparseIR.SamplingSVE}" href="#SparseIR.matrices-Tuple{SparseIR.SamplingSVE}"><code>SparseIR.matrices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrices(sve::AbstractSVE)</code></pre><p>SVD problems underlying the SVE.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/sve.jl#L156-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.matrix_from_gauss-Tuple{Any, Any, Any}" href="#SparseIR.matrix_from_gauss-Tuple{Any, Any, Any}"><code>SparseIR.matrix_from_gauss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_from_gauss(kernel, gauss_x, gauss_y)</code></pre><p>Compute matrix for kernel from Gauss rules.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/kernel.jl#L285-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.movedim-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Pair}} where {T, N}" href="#SparseIR.movedim-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Pair}} where {T, N}"><code>SparseIR.movedim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">movedim(arr::AbstractArray, src =&gt; dst)</code></pre><p>Move <code>arr</code>&#39;s dimension at <code>src</code> to <code>dst</code> while keeping the order of the remaining  dimensions unchanged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/sampling.jl#L110-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.ngauss-Tuple{SparseIR.SVEHintsLogistic}" href="#SparseIR.ngauss-Tuple{SparseIR.SVEHintsLogistic}"><code>SparseIR.ngauss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ngauss(hints)</code></pre><p>Gauss-Legendre order to use to guarantee accuracy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/kernel.jl#L467-L471">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.nsvals" href="#SparseIR.nsvals"><code>SparseIR.nsvals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nsvals(hints)</code></pre><p>Upper bound for number of singular values.</p><p>Upper bound on the number of singular values above the given threshold, i.e. where <code>s[l] ≥ ε * first(s)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/kernel.jl#L446-L453">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.overlap-Union{Tuple{T}, Tuple{SparseIR.PiecewiseLegendrePoly{T}, Any}} where T" href="#SparseIR.overlap-Union{Tuple{T}, Tuple{SparseIR.PiecewiseLegendrePoly{T}, Any}} where T"><code>SparseIR.overlap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlap(poly::PiecewiseLegendrePoly, f)</code></pre><p>Evaluate overlap integral of <code>poly</code> with arbitrary function <code>f</code>.</p><p>Given the function <code>f</code>, evaluate the integral::</p><pre><code class="nohighlight hljs">∫ dx * f(x) * poly(x)</code></pre><p>using adaptive Gauss-Legendre quadrature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/poly.jl#L74-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.piecewise-Tuple{Any, Vector}" href="#SparseIR.piecewise-Tuple{Any, Vector}"><code>SparseIR.piecewise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">piecewise(rule, edges)</code></pre><p>Piecewise quadrature with the same quadrature rule, but scaled.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/gauss.jl#L58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.postprocess" href="#SparseIR.postprocess"><code>SparseIR.postprocess</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">postprocess(sve::AbstractSVE, u, s, v, T=nothing)</code></pre><p>Construct the SVE result from the SVD.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/sve.jl#L169-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.quadrature-Tuple{Any, Any}" href="#SparseIR.quadrature-Tuple{Any, Any}"><code>SparseIR.quadrature</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">quadrature(rule, f)</code></pre><p>Approximate <code>f</code>&#39;s integral.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/gauss.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.reseat-Tuple{SparseIR.Rule, Any, Any}" href="#SparseIR.reseat-Tuple{SparseIR.Rule, Any, Any}"><code>SparseIR.reseat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reseat(rule, a, b)</code></pre><p>Reseat quadrature rule to new domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/gauss.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.roots-Tuple{SparseIR.PiecewiseLegendrePoly}" href="#SparseIR.roots-Tuple{SparseIR.PiecewiseLegendrePoly}"><code>SparseIR.roots</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">roots(poly)</code></pre><p>Find all roots of the piecewise polynomial <code>poly</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/poly.jl#L111-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.scale-Tuple{Any, Any}" href="#SparseIR.scale-Tuple{Any, Any}"><code>SparseIR.scale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scale(rule, factor)</code></pre><p>Scale weights by <code>factor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/gauss.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.segments_x" href="#SparseIR.segments_x"><code>SparseIR.segments_x</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">segments_x(kernel)</code></pre><p>Segments for piecewise polynomials on the <span>$x$</span> axis.</p><p>List of segments on the <span>$x$</span> axis for the associated piecewise polynomial. Should reflect the approximate position of roots of a high-order singular function in <span>$x$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/kernel.jl#L220-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.segments_y" href="#SparseIR.segments_y"><code>SparseIR.segments_y</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">segments_y(kernel)</code></pre><p>Segments for piecewise polynomials on the <span>$y$</span> axis.</p><p>List of segments on the <span>$y$</span> axis for the associated piecewise polynomial. Should reflect the approximate position of roots of a high-order singular function in <span>$y$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/kernel.jl#L231-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.sve_hints" href="#SparseIR.sve_hints"><code>SparseIR.sve_hints</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sve_hints(kernel, ε)</code></pre><p>Provide discretisation hints for the SVE routines.</p><p>Advises the SVE routines of discretisation parameters suitable in tranforming the (infinite) SVE into an (finite) SVD problem.</p><p>See also <a href="#SparseIR.AbstractSVEHints"><code>AbstractSVEHints</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/kernel.jl#L430-L439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.to_IR" href="#SparseIR.to_IR"><code>SparseIR.to_IR</code></a> — <span class="docstring-category">Function</span></header><section><div><p>From SPR to IR</p><p>g_spr:     Expansion coefficients in SPR</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/spr.jl#L99-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.truncate" href="#SparseIR.truncate"><code>SparseIR.truncate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">truncate(u, s, v, rtol=0, lmax=nothing)</code></pre><p>Truncate singular value expansion.</p><p><strong>Arguments</strong></p><pre><code class="nohighlight hljs">- `u`, `s`, `v`: Thin singular value expansion
- `rtol` : If given, only singular values satisfying
`s[l]/s[0] &gt; rtol` are retained.
- `lmax` : If given, at most the `lmax` most significant singular
values are retained.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/sve.jl#L306-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.weight_func-Tuple{SparseIR.AbstractKernel, SparseIR.Statistics}" href="#SparseIR.weight_func-Tuple{SparseIR.AbstractKernel, SparseIR.Statistics}"><code>SparseIR.weight_func</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">weight_func(kernel, statistics::Statistics)</code></pre><p>Return the weight function for the given statistics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/kernel.jl#L500-L504">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.xrange-Tuple{SparseIR.AbstractKernel}" href="#SparseIR.xrange-Tuple{SparseIR.AbstractKernel}"><code>SparseIR.xrange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">xrange(kernel)</code></pre><p>Return a tuple <span>$(x_\mathrm{min}, x_\mathrm{max})$</span> delimiting the range  of allowed <code>x</code> values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/kernel.jl#L167-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.ypower-Tuple{SparseIR.AbstractKernel}" href="#SparseIR.ypower-Tuple{SparseIR.AbstractKernel}"><code>SparseIR.ypower</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ypower(kernel)</code></pre><p>Power with which the <span>$y$</span> coordinate scales.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/kernel.jl#L476-L480">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.yrange-Tuple{SparseIR.AbstractKernel}" href="#SparseIR.yrange-Tuple{SparseIR.AbstractKernel}"><code>SparseIR.yrange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">yrange(kernel)</code></pre><p>Return a tuple <span>$(y_\mathrm{min}, y_\mathrm{max})$</span> delimiting the range  of allowed <code>y</code> values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/kernel.jl#L176-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseIR.Λ-Tuple{DimensionlessBasis}" href="#SparseIR.Λ-Tuple{DimensionlessBasis}"><code>SparseIR.Λ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Λ(basis)</code></pre><p>Basis cutoff parameter <code>Λ = β * ωmax</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/38e40639996a9ed38ba66f0179b66d6375818459/src/basis.jl#L99-L103">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.16 on <span class="colophon-date" title="Monday 23 May 2022 16:42">Monday 23 May 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
