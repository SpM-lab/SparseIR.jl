<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Private · SparseIR.jl</title><meta name="title" content="Private · SparseIR.jl"/><meta property="og:title" content="Private · SparseIR.jl"/><meta property="twitter:title" content="Private · SparseIR.jl"/><meta name="description" content="Documentation for SparseIR.jl."/><meta property="og:description" content="Documentation for SparseIR.jl."/><meta property="twitter:description" content="Documentation for SparseIR.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SparseIR.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../guide/">Guide</a></li><li><a class="tocitem" href="../public/">Public</a></li><li class="is-active"><a class="tocitem" href>Private</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Private</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Private</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SpM-lab/SparseIR.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SpM-lab/SparseIR.jl/blob/main/docs/src/private.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Private-names-index"><a class="docs-heading-anchor" href="#Private-names-index">Private names index</a><a id="Private-names-index-1"></a><a class="docs-heading-anchor-permalink" href="#Private-names-index" title="Permalink"></a></h1><p>These are not considered API and therefore not covered by any semver promises.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Core.Int-Tuple{MatsubaraFreq}" href="#Core.Int-Tuple{MatsubaraFreq}"><code>Core.Int</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get prefactor <code>n</code> for the Matsubara frequency <code>ω = n*π/β</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/freq.jl#L89-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Core.Integer-Tuple{MatsubaraFreq}" href="#Core.Integer-Tuple{MatsubaraFreq}"><code>Core.Integer</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get prefactor <code>n</code> for the Matsubara frequency <code>ω = n*π/β</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/freq.jl#L84-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Core.Union-Union{Tuple{MatsubaraFreq{S}}, Tuple{S}} where S" href="#Core.Union-Union{Tuple{MatsubaraFreq{S}}, Tuple{S}} where S"><code>Core.Union</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(polyFT::PiecewiseLegendreFT)(ω)</code></pre><p>Obtain Fourier transform of polynomial for given <code>MatsubaraFreq</code> <code>ω</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/poly.jl#L294-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.AbstractAugmentation" href="#SparseIR.AbstractAugmentation"><code>SparseIR.AbstractAugmentation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractAugmentation</code></pre><p>Scalar function in imaginary time/frequency.</p><p>This represents a single function in imaginary time and frequency, together with some auxiliary methods that make it suitable for augmenting a basis.</p><p>See also: <a href="../public/#SparseIR.AugmentedBasis"><code>AugmentedBasis</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/augment.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.AbstractBasis" href="#SparseIR.AbstractBasis"><code>SparseIR.AbstractBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractBasis</code></pre><p>Abstract base class for bases on the imaginary-time axis.</p><p>Let <code>basis</code> be an abstract basis. Then we can expand a two-point propagator  <code>G(τ)</code>, where <code>τ</code> is imaginary time, into a set of basis functions:</p><pre><code class="nohighlight hljs">G(τ) == sum(basis.u[l](τ) * g[l] for l in 1:length(basis)) + ϵ(τ),</code></pre><p>where <code>basis.u[l]</code> is the <code>l</code>-th basis function, <code>g[l]</code> is the associated expansion coefficient and <code>ϵ(τ)</code> is an error term. Similarly, the Fourier transform <code>Ĝ(n)</code>, where <code>n</code> is now a Matsubara frequency, can be expanded as follows:</p><pre><code class="nohighlight hljs">Ĝ(n) == sum(basis.uhat[l](n) * g[l] for l in 1:length(basis)) + ϵ(n),</code></pre><p>where <code>basis.uhat[l]</code> is now the Fourier transform of the basis function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/abstract.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.AbstractKernel" href="#SparseIR.AbstractKernel"><code>SparseIR.AbstractKernel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">(kernel::AbstractKernel)(x, y[, x₊, x₋])</code></pre><p>Evaluate <code>kernel</code> at point <code>(x, y)</code>.</p><p>The parameters <code>x₊</code> and <code>x₋</code>, if given, shall contain the values of <code>x - xₘᵢₙ</code> and <code>xₘₐₓ - x</code>, respectively. This is useful if either difference is to be formed and cancellation expected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/kernel.jl#L344-L352">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.AbstractKernel" href="#SparseIR.AbstractKernel"><code>SparseIR.AbstractKernel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractKernel</code></pre><p>Integral kernel <code>K(x, y)</code>.</p><p>Abstract base type for an integral kernel, i.e. a AbstractFloat binary function <span>$K(x, y)$</span> used in a Fredhold integral equation of the first kind:</p><p class="math-container">\[    u(x) = ∫ K(x, y) v(y) dy\]</p><p>where <span>$x ∈ [x_\mathrm{min}, x_\mathrm{max}]$</span> and <span>$y ∈ [y_\mathrm{min}, y_\mathrm{max}]$</span>. For its SVE to exist, the kernel must be square-integrable, for its singular values to decay exponentially, it must be smooth.</p><p>In general, the kernel is applied to a scaled spectral function <span>$ρ&#39;(y)$</span> as:</p><p class="math-container">\[    ∫ K(x, y) ρ&#39;(y) dy,\]</p><p>where <span>$ρ&#39;(y) = w(y) ρ(y)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/abstract.jl#L111-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.AbstractSVEHints" href="#SparseIR.AbstractSVEHints"><code>SparseIR.AbstractSVEHints</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractSVEHints</code></pre><p>Discretization hints for singular value expansion of a given kernel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/abstract.jl#L140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.AbstractSampling" href="#SparseIR.AbstractSampling"><code>SparseIR.AbstractSampling</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractSampling</code></pre><p>Abstract type for sparse sampling.</p><p>Encodes the &quot;basis transformation&quot; of a propagator from the truncated IR basis coefficients <code>G_ir[l]</code> to time/frequency sampled on sparse points <code>G(x[i])</code> together with its inverse, a least squares fit:</p><pre><code class="nohighlight hljs">     ________________                   ___________________
    |                |    evaluate     |                   |
    |     Basis      |----------------&gt;|     Value on      |
    |  coefficients  |&lt;----------------|  sampling points  |
    |________________|      fit        |___________________|</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/abstract.jl#L149-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.CentrosymmSVE" href="#SparseIR.CentrosymmSVE"><code>SparseIR.CentrosymmSVE</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CentrosymmSVE &lt;: AbstractSVE</code></pre><p>SVE of centrosymmetric kernel in block-diagonal (even/odd) basis.</p><p>For a centrosymmetric kernel <code>K</code>, i.e., a kernel satisfying: <code>K(x, y) == K(-x, -y)</code>, one can make the following ansatz for the singular functions:</p><pre><code class="nohighlight hljs">u[l](x) = ured[l](x) + sign[l] * ured[l](-x)
v[l](y) = vred[l](y) + sign[l] * ured[l](-y)</code></pre><p>where <code>sign[l]</code> is either <code>+1</code> or <code>-1</code>. This means that the singular value expansion can be block-diagonalized into an even and an odd part by (anti-)symmetrizing the kernel:</p><pre><code class="nohighlight hljs">K_even = K(x, y) + K(x, -y)
K_odd  = K(x, y) - K(x, -y)</code></pre><p>The <code>l</code>th basis function, restricted to the positive interval, is then the singular function of one of these kernels. If the kernel generates a Chebyshev system [1], then even and odd basis functions alternate.</p><p>[1]: A. Karlin, Total Positivity (1968).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/sve.jl#L49-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.LogisticKernelOdd" href="#SparseIR.LogisticKernelOdd"><code>SparseIR.LogisticKernelOdd</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LogisticKernelOdd &lt;: AbstractReducedKernel</code></pre><p>Fermionic analytical continuation kernel, odd.</p><p>In dimensionless variables <span>$x = 2τ/β - 1$</span>, <span>$y = βω/Λ$</span>, the fermionic integral kernel is a function on <span>$[-1, 1] × [-1, 1]$</span>:</p><p class="math-container">\[    K(x, y) = -\frac{\sinh(Λ x y / 2)}{\cosh(Λ y / 2)}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/kernel.jl#L94-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.PiecewiseLegendreFT" href="#SparseIR.PiecewiseLegendreFT"><code>SparseIR.PiecewiseLegendreFT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PiecewiseLegendreFT &lt;: Function</code></pre><p>Fourier transform of a piecewise Legendre polynomial.</p><p>For a given frequency index <code>n</code>, the Fourier transform of the Legendre function is defined as:</p><pre><code class="nohighlight hljs">    p̂(n) == ∫ dx exp(im * π * n * x / (xmax - xmin)) p(x)</code></pre><p>The polynomial is continued either periodically (<code>freq=:even</code>), in which case <code>n</code> must be even, or antiperiodically (<code>freq=:odd</code>), in which case <code>n</code> must be odd.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/poly.jl#L247-L260">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.PiecewiseLegendrePoly" href="#SparseIR.PiecewiseLegendrePoly"><code>SparseIR.PiecewiseLegendrePoly</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PiecewiseLegendrePoly &lt;: Function</code></pre><p>Piecewise Legendre polynomial.</p><p>Models a function on the interval <span>$[xmin, xmax]$</span> as a set of segments on the intervals <span>$S[i] = [a[i], a[i+1]]$</span>, where on each interval the function is expanded in scaled Legendre polynomials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/poly.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.PiecewiseLegendrePolyVector" href="#SparseIR.PiecewiseLegendrePolyVector"><code>SparseIR.PiecewiseLegendrePolyVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PiecewiseLegendrePolyVector</code></pre><p>Alias for <code>Vector{PiecewiseLegendrePoly}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/poly.jl#L164-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.PowerModel" href="#SparseIR.PowerModel"><code>SparseIR.PowerModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PowerModel</code></pre><p>Model from a high-frequency series expansion::</p><pre><code class="nohighlight hljs">A(iω) == sum(A[n] / (iω)^(n+1) for n in 1:N)</code></pre><p>where <span>$iω == i * π/2 * wn$</span> is a reduced imaginary frequency, i.e., <span>$wn$</span> is an odd/even number for fermionic/bosonic frequencies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/poly.jl#L230-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.ReducedKernel" href="#SparseIR.ReducedKernel"><code>SparseIR.ReducedKernel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReducedKernel</code></pre><p>Restriction of centrosymmetric kernel to positive interval.</p><p>For a kernel <span>$K$</span> on <span>$[-1, 1] × [-1, 1]$</span> that is centrosymmetric, i.e. <span>$K(x, y) = K(-x, -y)$</span>, it is straight-forward to show that the left/right singular vectors can be chosen as either odd or even functions.</p><p>Consequentially, they are singular functions of a reduced kernel <span>$K_\mathrm{red}$</span> on <span>$[0, 1] × [0, 1]$</span> that is given as either:</p><p class="math-container">\[    K_\mathrm{red}(x, y) = K(x, y) \pm K(x, -y)\]</p><p>This kernel is what this type represents. The full singular functions can be reconstructed by (anti-)symmetrically continuing them to the negative axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/kernel.jl#L72-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.RegularizedBoseKernelOdd" href="#SparseIR.RegularizedBoseKernelOdd"><code>SparseIR.RegularizedBoseKernelOdd</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RegularizedBoseKernelOdd &lt;: AbstractReducedKernel</code></pre><p>Bosonic analytical continuation kernel, odd.</p><p>In dimensionless variables <span>$x = 2 τ / β - 1$</span>, <span>$y = β ω / Λ$</span>, the fermionic integral kernel is a function on <span>$[-1, 1] × [-1, 1]$</span>:</p><p class="math-container">\[    K(x, y) = -y \frac{\sinh(Λ x y / 2)}{\sinh(Λ y / 2)}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/kernel.jl#L116-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.Rule" href="#SparseIR.Rule"><code>SparseIR.Rule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Rule{T&lt;:AbstractFloat}</code></pre><p>Quadrature rule.</p><p>Approximation of an integral over <code>[a, b]</code> by a sum over discrete points <code>x</code> with weights <code>w</code>:</p><p class="math-container">\[    ∫ f(x) ω(x) dx ≈ ∑_i f(x_i) w_i\]</p><p>where we generally have superexponential convergence for smooth <span>$f(x)$</span> in  the number of quadrature points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/gauss.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.SVEResult-Tuple{SparseIR.AbstractKernel}" href="#SparseIR.SVEResult-Tuple{SparseIR.AbstractKernel}"><code>SparseIR.SVEResult</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SVEResult(kernel::AbstractKernel;
    Twork=nothing, ε=nothing, lmax=typemax(Int),
    n_gauss=nothing, svd_strat=:auto,
    sve_strat=iscentrosymmetric(kernel) ? CentrosymmSVE : SamplingSVE
)</code></pre><p>Perform truncated singular value expansion of a kernel.</p><p>Perform a truncated singular value expansion (SVE) of an integral kernel <code>kernel : [xmin, xmax] x [ymin, ymax] -&gt; ℝ</code>:</p><pre><code class="nohighlight hljs">kernel(x, y) == sum(s[l] * u[l](x) * v[l](y) for l in (1, 2, 3, ...)),</code></pre><p>where <code>s[l]</code> are the singular values, which are ordered in non-increasing fashion, <code>u[l](x)</code> are the left singular functions, which form an orthonormal system on <code>[xmin, xmax]</code>, and <code>v[l](y)</code> are the right singular functions, which form an orthonormal system on <code>[ymin, ymax]</code>.</p><p>The SVE is mapped onto the singular value decomposition (SVD) of a matrix by expanding the kernel in piecewise Legendre polynomials (by default by using a collocation).</p><p><strong>Arguments</strong></p><ul><li><p><code>K::AbstractKernel</code>: Integral kernel to take SVE from.</p></li><li><p><code>ε::Real</code>: Accuracy target for the basis: attempt to have singular values down to a relative magnitude of <code>ε</code>, and have each singular value and singular vector be accurate to <code>ε</code>. A <code>Twork</code> with a machine epsilon of <code>ε^2</code> or lower is required to satisfy this. Defaults to <code>2.2e-16</code> if xprec is available, and <code>1.5e-8</code> otherwise.</p></li><li><p><code>cutoff::Real</code>: Relative cutoff for the singular values. A <code>Twork</code> with machine epsilon of <code>cutoff</code> is required to satisfy this. Defaults to a small multiple of the machine epsilon.</p><p>Note that <code>cutoff</code> and <code>ε</code> serve distinct purposes. <code>cutoff</code> reprsents the accuracy to which the kernel is reproduced, whereas <code>ε</code> is the accuracy to which the singular values and vectors are guaranteed.</p></li><li><p><code>lmax::Integer</code>: Maximum basis size. If given, only at most the <code>lmax</code> most significant singular values and associated singular functions are returned.</p></li><li><p>`n_gauss (int): Order of Legendre polynomials. Defaults to kernel hinted value.</p></li><li><p><code>Twork</code><code>: Working data type. Defaults to a data type with machine epsilon of at  most</code>ε^2<code>and at most</code>cutoff`, or otherwise most accurate data type available.</p></li><li><p><code>sve_strat::AbstractSVE</code>: SVE to SVD translation strategy. Defaults to <code>SamplingSVE</code>, optionally wrapped inside of a <code>CentrosymmSVE</code> if the kernel is centrosymmetric.</p></li><li><p><code>svd_strat</code> (&#39;fast&#39; or &#39;default&#39; or &#39;accurate&#39;): SVD solver. Defaults to fast (ID/RRQR) based solution when accuracy goals are moderate, and more accurate Jacobi-based algorithm otherwise.</p></li></ul><p>Returns: An <code>SVEResult</code> containing the truncated singular value expansion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/sve.jl#L99-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.SamplingSVE" href="#SparseIR.SamplingSVE"><code>SparseIR.SamplingSVE</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SamplingSVE &lt;: AbstractSVE</code></pre><p>SVE to SVD translation by sampling technique [1].</p><p>Maps the singular value expansion (SVE) of a kernel <code>kernel</code> onto the singular value decomposition of a matrix <code>A</code>. This is achieved by choosing two sets of Gauss quadrature rules: <code>(x, wx)</code> and <code>(y, wy)</code> and approximating the integrals in the SVE equations by finite sums. This implies that the singular values of the SVE are well-approximated by the singular values of the following matrix:</p><pre><code class="nohighlight hljs">A[i, j] = √(wx[i]) * K(x[i], y[j]) * √(wy[j])</code></pre><p>and the values of the singular functions at the Gauss sampling points can be reconstructed from the singular vectors <code>u</code> and <code>v</code> as follows:</p><pre><code class="nohighlight hljs">u[l,i] ≈ √(wx[i]) u[l](x[i])
v[l,j] ≈ √(wy[j]) u[l](y[j])</code></pre><p>[1] P. Hansen, Discrete Inverse Problems, Ch. 3.1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/sve.jl#L3-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.Statistics" href="#SparseIR.Statistics"><code>SparseIR.Statistics</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Statistics(zeta)</code></pre><p>Abstract type for quantum statistics (fermionic/bosonic/etc.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/freq.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.accuracy" href="#SparseIR.accuracy"><code>SparseIR.accuracy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">accuracy(basis::AbstractBasis)</code></pre><p>Accuracy of the basis.</p><p>Upper bound to the relative error of reprensenting a propagator with the given number of basis functions (number between 0 and 1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/abstract.jl#L27-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.canonicalize!-Tuple{Any, Any}" href="#SparseIR.canonicalize!-Tuple{Any, Any}"><code>SparseIR.canonicalize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">canonicalize!(u, v)</code></pre><p>Canonicalize basis.</p><p>Each SVD <code>(u[l], v[l])</code> pair is unique only up to a global phase, which may differ from implementation to implementation and also platform. We fix that gauge by demanding <code>u[l](1) &gt; 0</code>. This ensures a diffeomorphic connection to the Legendre polynomials as <code>Λ → 0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/sve.jl#L299-L308">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.choose_accuracy-Tuple{Any, Any, Any}" href="#SparseIR.choose_accuracy-Tuple{Any, Any, Any}"><code>SparseIR.choose_accuracy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">choose_accuracy(ε, Twork[, svd_strat])</code></pre><p>Choose work type and accuracy based on specs and defaults</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/sve.jl#L264-L268">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.compute_unl_inner-Tuple{SparseIR.PiecewiseLegendrePoly, Any}" href="#SparseIR.compute_unl_inner-Tuple{SparseIR.PiecewiseLegendrePoly, Any}"><code>SparseIR.compute_unl_inner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_unl_inner(poly, wn)</code></pre><p>Compute piecewise Legendre to Matsubara transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/poly.jl#L408-L412">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.conv_radius" href="#SparseIR.conv_radius"><code>SparseIR.conv_radius</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">conv_radius(kernel)</code></pre><p>Convergence radius of the Matsubara basis asymptotic model.</p><p>For improved relative numerical accuracy, the IR basis functions on the Matsubara axis <code>uhat(basis, n)</code> can be evaluated from an asymptotic expression for <code>abs(n) &gt; conv_radius</code>. If <code>isinf(conv_radius)</code>, then the asymptotics are unused (the default).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/kernel.jl#L465-L474">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.default_matsubara_sampling_points" href="#SparseIR.default_matsubara_sampling_points"><code>SparseIR.default_matsubara_sampling_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">default_matsubara_sampling_points(basis::AbstractBasis; positive_only=false)</code></pre><p>Default sampling points on the imaginary frequency axis.</p><p><strong>Arguments</strong></p><ul><li><code>positive_only::Bool</code>: Only return non-negative frequencies. This is useful if the object to be fitted is symmetric in Matsubura frequency, <code>ĝ(ω) == conj(ĝ(-ω))</code>, or, equivalently, real in imaginary time.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/abstract.jl#L55-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.default_tau_sampling_points" href="#SparseIR.default_tau_sampling_points"><code>SparseIR.default_tau_sampling_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">default_tau_sampling_points(basis::AbstractBasis)</code></pre><p>Default sampling points on the imaginary time/x axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/abstract.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.deriv-Union{Tuple{SparseIR.PiecewiseLegendrePoly}, Tuple{n}, Tuple{SparseIR.PiecewiseLegendrePoly, Val{n}}} where n" href="#SparseIR.deriv-Union{Tuple{SparseIR.PiecewiseLegendrePoly}, Tuple{n}, Tuple{SparseIR.PiecewiseLegendrePoly, Val{n}}} where n"><code>SparseIR.deriv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deriv(poly[, ::Val{n}=Val(1)])</code></pre><p>Get polynomial for the <code>n</code>th derivative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/poly.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.eval_matrix" href="#SparseIR.eval_matrix"><code>SparseIR.eval_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eval_matrix(T, basis, x)</code></pre><p>Return evaluation matrix from coefficients to sampling points. <code>T &lt;: AbstractSampling</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/sampling.jl#L95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.find_extrema-Tuple{SparseIR.PiecewiseLegendreFT}" href="#SparseIR.find_extrema-Tuple{SparseIR.PiecewiseLegendreFT}"><code>SparseIR.find_extrema</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_extrema(polyFT::PiecewiseLegendreFT; part=nothing, grid=DEFAULT_GRID)</code></pre><p>Obtain extrema of Fourier-transformed polynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/poly.jl#L334-L338">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.finite_temp_bases" href="#SparseIR.finite_temp_bases"><code>SparseIR.finite_temp_bases</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">finite_temp_bases(β::Real, ωmax::Real, ε=nothing;
                  kernel=LogisticKernel(β * ωmax), sve_result=SVEResult(kernel; ε))</code></pre><p>Construct <code>FiniteTempBasis</code> objects for fermion and bosons using the same <code>LogisticKernel</code> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/basis.jl#L155-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.from_IR" href="#SparseIR.from_IR"><code>SparseIR.from_IR</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">from_IR(dlr::DiscreteLehmannRepresentation, gl::AbstractArray, dims=1)</code></pre><p>From IR to DLR. <code>gl</code>`: Expansion coefficients in IR.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/dlr.jl#L113-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.get_symmetrized-Tuple{SparseIR.AbstractKernel, Any}" href="#SparseIR.get_symmetrized-Tuple{SparseIR.AbstractKernel, Any}"><code>SparseIR.get_symmetrized</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_symmetrized(kernel, sign)</code></pre><p>Construct a symmetrized version of <code>kernel</code>, i.e. <code>kernel(x, y) + sign * kernel(x, -y)</code>.</p><div class="admonition is-warning"><header class="admonition-header">Beware!</header><div class="admonition-body"><p>By default, this returns a simple wrapper over the current instance which naively performs the sum. You may want to override this to avoid cancellation.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/kernel.jl#L293-L302">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.get_tnl-Tuple{Any, Any}" href="#SparseIR.get_tnl-Tuple{Any, Any}"><code>SparseIR.get_tnl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_tnl(l, w)</code></pre><p>Fourier integral of the <code>l</code>-th Legendre polynomial::</p><pre><code class="nohighlight hljs">Tₗ(ω) == ∫ dx exp(iωx) Pₗ(x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/poly.jl#L431-L437">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.giw-Tuple{Any, Integer}" href="#SparseIR.giw-Tuple{Any, Integer}"><code>SparseIR.giw</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">giw(polyFT, wn)</code></pre><p>Return model Green&#39;s function for reduced frequencies</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/poly.jl#L316-L320">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.iscentrosymmetric" href="#SparseIR.iscentrosymmetric"><code>SparseIR.iscentrosymmetric</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iscentrosymmetric(kernel)</code></pre><p>Return <code>true</code> if <code>kernel(x, y) == kernel(-x, -y)</code> for all values of <code>x</code> and <code>y</code> in range. This allows the kernel to be block-diagonalized, speeding up the singular value expansion by a factor of 4. Defaults to <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/kernel.jl#L332-L338">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.iswellconditioned-Tuple{SparseIR.AbstractBasis}" href="#SparseIR.iswellconditioned-Tuple{SparseIR.AbstractBasis}"><code>SparseIR.iswellconditioned</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iswellconditioned(basis::AbstractBasis)</code></pre><p>Returns true if the sampling is expected to be well-conditioned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/abstract.jl#L102-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.joinrules-Union{Tuple{AbstractArray{SparseIR.Rule{T}, 1}}, Tuple{T}} where T" href="#SparseIR.joinrules-Union{Tuple{AbstractArray{SparseIR.Rule{T}, 1}}, Tuple{T}} where T"><code>SparseIR.joinrules</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">joinrules(rules)</code></pre><p>Join multiple Gauss quadratures together.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/gauss.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.legder-Union{Tuple{AbstractMatrix{T}}, Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T" href="#SparseIR.legder-Union{Tuple{AbstractMatrix{T}}, Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T"><code>SparseIR.legder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">legder</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/_specfuncs.jl#L46-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.legendre-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T" href="#SparseIR.legendre-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T"><code>SparseIR.legendre</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">legendre(n[, T])</code></pre><p>Gauss-Legendre quadrature with <code>n</code> points on [-1, 1].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/gauss.jl#L90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.legendre_collocation" href="#SparseIR.legendre_collocation"><code>SparseIR.legendre_collocation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">legendre_collocation(rule, n=length(rule.x))</code></pre><p>Generate collocation matrix from Gauss-Legendre rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/gauss.jl#L97-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.legvander-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer}} where T" href="#SparseIR.legvander-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer}} where T"><code>SparseIR.legvander</code></a> — <span class="docstring-category">Method</span></header><section><div><p>legvander(x, deg)</p><p>Pseudo-Vandermonde matrix of degree <code>deg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/_specfuncs.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.matop!-Union{Tuple{N}, Tuple{T}, Tuple{S}, Tuple{AbstractArray{S, N}, Any, AbstractArray{T, N}, Any, Any}} where {S, T, N}" href="#SparseIR.matop!-Union{Tuple{N}, Tuple{T}, Tuple{S}, Tuple{AbstractArray{S, N}, Any, AbstractArray{T, N}, Any, Any}} where {S, T, N}"><code>SparseIR.matop!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matop!(buffer, mat, arr::AbstractArray, op, dim)</code></pre><p>Apply the operator <code>op</code> to the matrix <code>mat</code> and to the array <code>arr</code> along the first dimension (dim=1) or the last dimension (dim=N).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/sampling.jl#L228-L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.matop_along_dim!-Union{Tuple{N}, Tuple{T}, Tuple{Any, Any, AbstractArray{T, N}, Any, Any}} where {T, N}" href="#SparseIR.matop_along_dim!-Union{Tuple{N}, Tuple{T}, Tuple{Any, Any, AbstractArray{T, N}, Any, Any}} where {T, N}"><code>SparseIR.matop_along_dim!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matop_along_dim!(buffer, mat, arr::AbstractArray, dim::Integer, op)</code></pre><p>Apply the operator <code>op</code> to the matrix <code>mat</code> and to the array <code>arr</code> along the dimension <code>dim</code>, writing the result to <code>buffer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/sampling.jl#L203-L208">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.matrices-Tuple{SparseIR.SamplingSVE}" href="#SparseIR.matrices-Tuple{SparseIR.SamplingSVE}"><code>SparseIR.matrices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrices(sve::AbstractSVE)</code></pre><p>SVD problems underlying the SVE.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/sve.jl#L178-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.matrix_from_gauss-Union{Tuple{T}, Tuple{Any, SparseIR.Rule{T}, SparseIR.Rule{T}}} where T" href="#SparseIR.matrix_from_gauss-Union{Tuple{T}, Tuple{Any, SparseIR.Rule{T}, SparseIR.Rule{T}}} where T"><code>SparseIR.matrix_from_gauss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix_from_gauss(kernel, gauss_x, gauss_y)</code></pre><p>Compute matrix for kernel from Gauss rules.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/kernel.jl#L255-L259">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.movedim-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Pair}} where {T, N}" href="#SparseIR.movedim-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Pair}} where {T, N}"><code>SparseIR.movedim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">movedim(arr::AbstractArray, src =&gt; dst)</code></pre><p>Move <code>arr</code>&#39;s dimension at <code>src</code> to <code>dst</code> while keeping the order of the remaining dimensions unchanged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/sampling.jl#L183-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.ngauss" href="#SparseIR.ngauss"><code>SparseIR.ngauss</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ngauss(hints)</code></pre><p>Gauss-Legendre order to use to guarantee accuracy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/kernel.jl#L445-L449">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.nsvals-Tuple{SparseIR.SVEHintsLogistic}" href="#SparseIR.nsvals-Tuple{SparseIR.SVEHintsLogistic}"><code>SparseIR.nsvals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nsvals(hints)</code></pre><p>Upper bound for number of singular values.</p><p>Upper bound on the number of singular values above the given threshold, i.e. where <code>s[l] ≥ ε * first(s)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/kernel.jl#L425-L432">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.phase_stable-Tuple{Any, Integer}" href="#SparseIR.phase_stable-Tuple{Any, Integer}"><code>SparseIR.phase_stable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phase_stable(poly, wn)</code></pre><p>Phase factor for the piecewise Legendre to Matsubara transform.</p><p>Compute the following phase factor in a stable way:</p><pre><code class="nohighlight hljs">exp.(iπ/2 * wn * cumsum(poly.Δx))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/poly.jl#L470-L478">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.piecewise-Tuple{Any, Vector}" href="#SparseIR.piecewise-Tuple{Any, Vector}"><code>SparseIR.piecewise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">piecewise(rule, edges)</code></pre><p>Piecewise quadrature with the same quadrature rule, but scaled.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/gauss.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.postprocess-Tuple{SparseIR.SamplingSVE, Any, Any, Any}" href="#SparseIR.postprocess-Tuple{SparseIR.SamplingSVE, Any, Any, Any}"><code>SparseIR.postprocess</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">postprocess(sve::AbstractSVE, u, s, v)</code></pre><p>Construct the SVE result from the SVD.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/sve.jl#L191-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.rescale-Tuple{FiniteTempBasis, Any}" href="#SparseIR.rescale-Tuple{FiniteTempBasis, Any}"><code>SparseIR.rescale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rescale(basis::FiniteTempBasis, new_β)</code></pre><p>Return a basis for different temperature.</p><p>Uses the same kernel with the same <span>$ε$</span>, but a different temperature. Note that this implies a different UV cutoff <span>$ωmax$</span>, since <span>$Λ == β * ωmax$</span> stays constant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/basis.jl#L139-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.reseat-Tuple{SparseIR.Rule, Any, Any}" href="#SparseIR.reseat-Tuple{SparseIR.Rule, Any, Any}"><code>SparseIR.reseat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reseat(rule, a, b)</code></pre><p>Reseat quadrature rule to new domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/gauss.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.roots-Tuple{SparseIR.PiecewiseLegendrePoly}" href="#SparseIR.roots-Tuple{SparseIR.PiecewiseLegendrePoly}"><code>SparseIR.roots</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">roots(poly)</code></pre><p>Find all roots of the piecewise polynomial <code>poly</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/poly.jl#L108-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.scale-Tuple{Any, Any}" href="#SparseIR.scale-Tuple{Any, Any}"><code>SparseIR.scale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scale(rule, factor)</code></pre><p>Scale weights by <code>factor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/gauss.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.segments_x-Union{Tuple{SparseIR.SVEHintsLogistic}, Tuple{T}, Tuple{SparseIR.SVEHintsLogistic, Type{T}}} where T" href="#SparseIR.segments_x-Union{Tuple{SparseIR.SVEHintsLogistic}, Tuple{T}, Tuple{SparseIR.SVEHintsLogistic, Type{T}}} where T"><code>SparseIR.segments_x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">segments_x(sve_hints::AbstractSVEHints[, T])</code></pre><p>Segments for piecewise polynomials on the <span>$x$</span> axis.</p><p>List of segments on the <span>$x$</span> axis for the associated piecewise polynomial. Should reflect the approximate position of roots of a high-order singular function in <span>$x$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/kernel.jl#L193-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.segments_y-Union{Tuple{SparseIR.SVEHintsLogistic}, Tuple{T}, Tuple{SparseIR.SVEHintsLogistic, Type{T}}} where T" href="#SparseIR.segments_y-Union{Tuple{SparseIR.SVEHintsLogistic}, Tuple{T}, Tuple{SparseIR.SVEHintsLogistic, Type{T}}} where T"><code>SparseIR.segments_y</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">segments_y(sve_hints::AbstractSVEHints[, T])</code></pre><p>Segments for piecewise polynomials on the <span>$y$</span> axis.</p><p>List of segments on the <span>$y$</span> axis for the associated piecewise polynomial. Should reflect the approximate position of roots of a high-order singular function in <span>$y$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/kernel.jl#L210-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.shift_xmid-Tuple{Any, Any}" href="#SparseIR.shift_xmid-Tuple{Any, Any}"><code>SparseIR.shift_xmid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shift_xmid(knots, Δx)</code></pre><p>Return midpoint relative to the nearest integer plus a shift.</p><p>Return the midpoints <code>xmid</code> of the segments, as pair <code>(diff, shift)</code>, where shift is in <code>(0, 1, -1)</code> and <code>diff</code> is a float such that <code>xmid == shift + diff</code> to floating point accuracy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/poly.jl#L443-L451">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.significance" href="#SparseIR.significance"><code>SparseIR.significance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">significance(basis::AbstractBasis)</code></pre><p>Return vector <code>σ</code>, where <code>0 ≤ σ[i] ≤ 1</code> is the significance level of the <code>i</code>-th basis function. If <code>ϵ</code> is the desired accuracy to which to represent a propagator, then any basis function where <code>σ[i] &lt; ϵ</code> can be neglected.</p><p>For the IR basis, we simply have that <code>σ[i] = s[i] / first(s)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/abstract.jl#L37-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.split-Tuple{Any, Real}" href="#SparseIR.split-Tuple{Any, Real}"><code>SparseIR.split</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">split(poly, x)</code></pre><p>Split segment.</p><p>Find segment of poly&#39;s domain that covers <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/poly.jl#L128-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.statistics-Union{Tuple{SparseIR.AbstractBasis{S}}, Tuple{S}} where S&lt;:SparseIR.Statistics" href="#SparseIR.statistics-Union{Tuple{SparseIR.AbstractBasis{S}}, Tuple{S}} where S&lt;:SparseIR.Statistics"><code>SparseIR.statistics</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">statistics(basis::AbstractBasis)</code></pre><p>Quantum statistic (Statistics instance, Fermionic() or Bosonic()).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/abstract.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.sve_hints" href="#SparseIR.sve_hints"><code>SparseIR.sve_hints</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sve_hints(kernel, ε)</code></pre><p>Provide discretisation hints for the SVE routines.</p><p>Advises the SVE routines of discretisation parameters suitable in tranforming the (infinite) SVE into an (finite) SVD problem.</p><p>See also <a href="#SparseIR.AbstractSVEHints"><code>AbstractSVEHints</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/kernel.jl#L410-L419">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.to_IR" href="#SparseIR.to_IR"><code>SparseIR.to_IR</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">to_IR(dlr::DiscreteLehmannRepresentation, g_dlr::AbstractArray, dims=1)</code></pre><p>From DLR to IR. <code>g_dlr</code>`: Expansion coefficients in DLR.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/dlr.jl#L122-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.truncate-Tuple{Any, Any, Any}" href="#SparseIR.truncate-Tuple{Any, Any, Any}"><code>SparseIR.truncate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">truncate(u, s, v; rtol=0.0, lmax=typemax(Int))</code></pre><p>Truncate singular value expansion.</p><p><strong>Arguments</strong></p><pre><code class="nohighlight hljs">- `u`, `s`, `v`: Thin singular value expansion
- `rtol`: Only singular values satisfying `s[l]/s[1] &gt; rtol` are retained.
- `lmax`: At most the `lmax` most significant singular values are retained.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/sve.jl#L317-L327">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.value-Tuple{MatsubaraFreq, Real}" href="#SparseIR.value-Tuple{MatsubaraFreq, Real}"><code>SparseIR.value</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get value of the Matsubara frequency <code>ω = n*π/β</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/freq.jl#L94-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.valueim-Tuple{MatsubaraFreq, Real}" href="#SparseIR.valueim-Tuple{MatsubaraFreq, Real}"><code>SparseIR.valueim</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get complex value of the Matsubara frequency <code>iω = iπ/β * n</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/freq.jl#L99-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.weight_func" href="#SparseIR.weight_func"><code>SparseIR.weight_func</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">weight_func(kernel, statistics::Statistics)</code></pre><p>Return the weight function for the given statistics.</p><ul><li>Fermion: <code>w(x) == 1</code></li><li>Boson: <code>w(y) == 1/tanh(Λ*y/2)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/kernel.jl#L480-L487">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.workarrlength-Tuple{SparseIR.AbstractSampling, AbstractArray}" href="#SparseIR.workarrlength-Tuple{SparseIR.AbstractSampling, AbstractArray}"><code>SparseIR.workarrlength</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">workarrlength(smpl::AbstractSampling, al; dim=1)</code></pre><p>Return length of workarr for <code>fit!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/sampling.jl#L154-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.xrange" href="#SparseIR.xrange"><code>SparseIR.xrange</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">xrange(kernel)</code></pre><p>Return a tuple <span>$(x_\mathrm{min}, x_\mathrm{max})$</span> delimiting the range of allowed <code>x</code> values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/kernel.jl#L138-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.ypower" href="#SparseIR.ypower"><code>SparseIR.ypower</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ypower(kernel)</code></pre><p>Power with which the <span>$y$</span> coordinate scales.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/kernel.jl#L455-L459">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.yrange" href="#SparseIR.yrange"><code>SparseIR.yrange</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">yrange(kernel)</code></pre><p>Return a tuple <span>$(y_\mathrm{min}, y_\mathrm{max})$</span> delimiting the range of allowed <code>y</code> values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/kernel.jl#L148-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.zeta-Tuple{MatsubaraFreq}" href="#SparseIR.zeta-Tuple{MatsubaraFreq}"><code>SparseIR.zeta</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get statistics <code>ζ</code> for Matsubara frequency <code>ω = (2*m+ζ)*π/β</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/freq.jl#L104-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.Λ" href="#SparseIR.Λ"><code>SparseIR.Λ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Λ(basis::AbstractBasis)
lambda(basis::AbstractBasis)</code></pre><p>Basis cutoff parameter, <code>Λ = β * ωmax</code>, or None if not present</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/abstract.jl#L75-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.β-Tuple{SparseIR.AbstractBasis}" href="#SparseIR.β-Tuple{SparseIR.AbstractBasis}"><code>SparseIR.β</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">β(basis::AbstractBasis)
beta(basis::AbstractBasis)</code></pre><p>Inverse temperature or <code>nothing</code> if unscaled basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/abstract.jl#L93-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR.ωmax" href="#SparseIR.ωmax"><code>SparseIR.ωmax</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ωmax(basis::AbstractBasis)
wmax(basis::AbstractBasis)</code></pre><p>Real frequency cutoff or <code>nothing</code> if unscaled basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/abstract.jl#L84-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR._LinAlg.givens_lmul-Union{Tuple{T}, Tuple{Tuple{T, T}, Any}} where T" href="#SparseIR._LinAlg.givens_lmul-Union{Tuple{T}, Tuple{Tuple{T, T}, Any}} where T"><code>SparseIR._LinAlg.givens_lmul</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apply Givens rotation to vector:</p><pre><code class="nohighlight hljs">  [ a ]  =  [  c   s ] [ x ]
  [ b ]     [ -s   c ] [ y ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/_linalg.jl#L160-L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR._LinAlg.givens_params-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractFloat" href="#SparseIR._LinAlg.givens_params-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractFloat"><code>SparseIR._LinAlg.givens_params</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute Givens rotation <code>R</code> matrix that satisfies:</p><pre><code class="nohighlight hljs">[  c  s ] [ f ]     [ r ]
[ -s  c ] [ g ]  =  [ 0 ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/_linalg.jl#L138-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR._LinAlg.rrqr!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat" href="#SparseIR._LinAlg.rrqr!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>SparseIR._LinAlg.rrqr!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Truncated rank-revealing QR decomposition with full column pivoting.</p><p>Decomposes a <code>(m, n)</code> matrix <code>A</code> into the product:</p><pre><code class="nohighlight hljs">A[:,piv] == Q * R</code></pre><p>where <code>Q</code> is an <code>(m, k)</code> isometric matrix, <code>R</code> is a <code>(k, n)</code> upper triangular matrix, <code>piv</code> is a permutation vector, and <code>k</code> is chosen such that the relative tolerance <code>tol</code> is met in the equality above.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/_linalg.jl#L9-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR._LinAlg.rrqr-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat" href="#SparseIR._LinAlg.rrqr-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>SparseIR._LinAlg.rrqr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Truncated rank-revealing QR decomposition with full column pivoting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/_linalg.jl#L73-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR._LinAlg.svd2x2-Union{Tuple{T}, NTuple{4, T}} where T" href="#SparseIR._LinAlg.svd2x2-Union{Tuple{T}, NTuple{4, T}} where T"><code>SparseIR._LinAlg.svd2x2</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Perform the SVD of an arbitrary two-by-two matrix:</p><pre><code class="nohighlight hljs">  [ a11  a12 ]  =  [  cu  -su ] [ smax     0 ] [  cv   sv ]
  [ a21  a22 ]     [  su   cu ] [    0  smin ] [ -sv   cv ]</code></pre><p>Note that smax and smin can be negative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/_linalg.jl#L223-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR._LinAlg.svd2x2-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:AbstractFloat" href="#SparseIR._LinAlg.svd2x2-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:AbstractFloat"><code>SparseIR._LinAlg.svd2x2</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Perform the SVD of upper triangular two-by-two matrix:</p><pre><code class="nohighlight hljs">  [ f    g   ]  =  [  cu  -su ] [ smax     0 ] [  cv   sv ]
  [ 0    h   ]     [  su   cu ] [    0  smin ] [ -sv   cv ]</code></pre><p>Note that smax and smin can be negative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/_linalg.jl#L172-L179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR._LinAlg.svd_jacobi!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T" href="#SparseIR._LinAlg.svd_jacobi!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>SparseIR._LinAlg.svd_jacobi!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Singular value decomposition using Jacobi rotations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/_linalg.jl#L289-L291">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR._LinAlg.svd_jacobi-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T" href="#SparseIR._LinAlg.svd_jacobi-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>SparseIR._LinAlg.svd_jacobi</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Singular value decomposition using Jacobi rotations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/_linalg.jl#L309-L311">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR._LinAlg.truncate_qr_result-Union{Tuple{T}, Tuple{LinearAlgebra.QRPivoted{T, S, C} where {S&lt;:AbstractMatrix{T}, C&lt;:AbstractVector{T}}, Integer}} where T" href="#SparseIR._LinAlg.truncate_qr_result-Union{Tuple{T}, Tuple{LinearAlgebra.QRPivoted{T, S, C} where {S&lt;:AbstractMatrix{T}, C&lt;:AbstractVector{T}}, Integer}} where T"><code>SparseIR._LinAlg.truncate_qr_result</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Truncate RRQR result low-rank</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/_linalg.jl#L86-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR._LinAlg.tsvd!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat" href="#SparseIR._LinAlg.tsvd!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>SparseIR._LinAlg.tsvd!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Truncated singular value decomposition.</p><p>Decomposes an <code>(m, n)</code> matrix <code>A</code> into the product:</p><pre><code class="nohighlight hljs">A == U * (s .* VT)</code></pre><p>where <code>U</code> is a <code>(m, k)</code> matrix with orthogonal columns, <code>VT</code> is a <code>(k, n)</code> matrix with orthogonal rows and <code>s</code> are the singular values, a set of <code>k</code> nonnegative numbers in non-ascending order. The SVD is truncated in the sense that singular values below <code>tol</code> are discarded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/_linalg.jl#L99-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseIR._LinAlg.tsvd-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat" href="#SparseIR._LinAlg.tsvd-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>SparseIR._LinAlg.tsvd</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Truncated singular value decomposition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SpM-lab/SparseIR.jl/blob/811d8ac6a9b786a6cf66941ded87d67adb81db94/src/_linalg.jl#L128-L130">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../public/">« Public</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Thursday 7 March 2024 18:54">Thursday 7 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
