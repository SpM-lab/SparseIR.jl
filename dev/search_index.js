var documenterSearchIndex = {"docs":
[{"location":"guide/#guide","page":"Guide","title":"Introduction","text":"We present SparseIR.jl, a Julia library for constructing and working with the intermediate representation of correlation functions [1–4]. The intermediate representation (IR) takes the matrix kernel transforming propagators between the real-frequency axis and the imaginary-time axis and performs a singular value expansion (SVE) on it. This decomposes the matrix kernel into a set of singular values as well as two sets of functions. One of those lives on the real-frequency axis and one on the imaginary-time axis. Expressing a propagator in terms of either basis–by an ordinary least squares fit–then allows us to easily transition between them. In combination with a prescription for constructing sparse sets of sampling points on each axis, we have a method for optimally compressing propagators.\n\nSparseIR.jl implements the intermediate representation, providing on-the-fly computation of basis functions and singular values accurate to full precision along with routines for sparse sampling. It is further fully unit tested, featuring near-complete code coverage. Here, we will explain its inner structure by means of an example use case. In preparing this document, SparseIR.jl version 1.0.18 and Julia version 1.11.1 were used.","category":"section"},{"location":"guide/#Problem-statement","page":"Guide","title":"Problem statement","text":"We take a problem to be solved from the sparse-ir paper [4].\n\nLet us perform self-consistent second-order perturbation theory for the single impurity Anderson model at finite temperature. Its Hamiltonian is given by    H = U c^dagger_uparrow c^dagger_downarrow c_downarrow c_uparrow + sum_psigma big(V_psigma  f_psigma^dagger c_sigma + V_psigma^* c_sigma^dagger f_psigmabig) + sum_psigma epsilon_p f_psigma^dagger f_psigmawhere U is the electron interaction strength, c_sigma annihilates an electron on the impurity, f_psigma annihilates an electron in the bath, dagger denotes the Hermitian conjugate, pinmathbb R is bath momentum, and sigmainuparrow downarrow the spin. The hybridization strength V_psigma and bath energies epsilon_p are chosen such that the non-interacting density of states is semi-elliptic with a half-bandwidth of one, rho_0(omega) = frac2pisqrt1-omega^2, U=12, beta=10, [...]","category":"section"},{"location":"guide/#outline","page":"Guide","title":"Outline","text":"To provide an overview, we first give the full code used to solve the problem with SparseIR.jl.\n\nusing SparseIR\n\nβ = 10.0; ωmax = 8.0; ε = 1e-6;\n\n# Construct the IR basis and sparse sampling for fermionic propagators\nbasis = FiniteTempBasis{Fermionic}(β, ωmax, ε)\nsτ = TauSampling(basis)\nsiω = MatsubaraSampling(basis; positive_only=true)\n\n# Solve the single impurity Anderson model coupled to a bath with a\n# semicircular density of states with unit half bandwidth.\nU = 1.2\nρ₀(ω) = 2/π * √(1 - clamp(ω, -1, +1)^2)\n\n# Compute the IR basis coefficients for the non-interacting propagator\nρ₀l = overlap.(basis.v, ρ₀)\nG₀l = -basis.s .* ρ₀l\n\n# Self-consistency loop: alternate between second-order expression for the\n# self-energy and the Dyson equation until convergence.\nGl = copy(G₀l)\nΣl = zero(Gl)\nGl_prev = zero(Gl)\nG₀iω = evaluate(siω, G₀l)\nwhile !isapprox(Gl, Gl_prev, rtol=ε)\n    Gl_prev = copy(Gl)\n    Gτ = evaluate(sτ, Gl)\n    Στ = @. U^2 * Gτ^3\n    Σl = fit(sτ, Στ)\n    Σiω = evaluate(siω, Σl)\n    Giω = @. (G₀iω^-1 - Σiω)^-1\n    Gl = fit(siω, Giω)\nend\n\nNote that this script as presented is optimized for readability instead of performance; in practice, you would want to make minor adjustments to ensure maximum type inferrability and full type stability, among other things putting the code in a function instead of executing in global scope. Such an performance-optimized version is provided in Appendix: Optimized script. The following is a detailed explanation of what happens here under the hood and why.","category":"section"},{"location":"guide/#Treatment","page":"Guide","title":"Treatment","text":"If we take the second-order expression for the self-energy, which at half filling is simply \n\n    Sigma(tau) = U^2 pqtyG(tau)^3\n\nand the Dyson equation\n\n    hat G(mathrmiomega) = pqtypqtyhat G_0(mathrmiomega)^-1 - hatSigma(mathrmiomega)^-1\n\nwe have a system of two coupled equations. The first one is diagonal in tau and the second is diagonal in mathrmiomega, so we need a way of converting efficiently between these two axes.","category":"section"},{"location":"guide/#Basis-construction","page":"Guide","title":"Basis construction","text":"We first import SparseIR and construct an appropriate basis. To do so, we must first choose an appropriate UV frequency cutoff omega_mathrmmax, representing the maximum bandwidth our basis can capture. The non-interacting density of states in our problem is semi-elliptic with half-bandwidth 1. Once we introduce interactions via the interaction strength U, this band splits into the lower and the upper Hubbard bands, centered around omega = pm U2 respectively. So the bandwidth should be around 32 at a minimum, but we choose more than twice that with omega_mathrmmax = 8 to be safe.\n\njulia> using SparseIR\n\njulia> β = 10.0; ωmax = 8.0; ε = 1e-6;\n\njulia> basis = FiniteTempBasis{Fermionic}(β, ωmax, ε)\n20-element FiniteTempBasis{Fermionic} with β = 10.0, ωmax = 8.0 and singular values:\n 1.4409730317545617\n 1.2153954454510802\n 0.7652662478347486\n 0.49740673945822533\n 0.288562095623106\n 0.1639819552743817\n 0.08901271087151318\n 0.046837974354297436\n 0.023857653233506308\n 0.01179373309602762\n 0.005662400021411787\n 0.0026427291749051072\n 0.0011996720525663963\n 0.0005299554043095754\n 0.00022790287514550545\n 9.544046906619884e-5\n 3.8931895383167936e-5\n 1.5472919567017398e-5\n 5.992753725069063e-6\n 2.2623276239584257e-6\n\nThere is quite a lot happening behind the scenes in this first innocuous-looking statement, so we will break it down:","category":"section"},{"location":"guide/#Kernel","page":"Guide","title":"Kernel","text":"Consider a propagator/Green's function defined on the imaginary-time axis\n\n    G(tau) equiv -evT_tau A(tau) B(0)\n\nand the associated spectral function in real frequency rho(omega) = -(1pi) mathrmImG(omega). These are related via\n\n    G(tau) = -int_-omega_mathrmmax^+omega_mathrmmax ddomega tilde K(tau omega) rho(omega)\n\nwith the integral kernel\n\n    tilde K(tau omega) = frace^-tauomegae^-betaomega + 1\n\nmediating between them. If we perform an SVE on this kernel, yielding the decomposition\n\n    tilde K(tau omega) = sum_ell=1^infty U_ell(tau) S_ell V_ell(omega)\n\nwith the U_ells and V_ells each forming an orthonormal system, we can write\n\n    G(tau) = sum_ell=1^infty U_ell(tau) G_ell = sum_ell=1^L U_ell(tau) G_ell + epsilon_L+1(tau)\n\nwith expansion coefficients given by\n\n    G_ell = -int_-omega_mathrmmax^+omega_mathrmmax ddomega  S_ell V_ell(omega) rho(omega)\n\nThe singular values decay at least exponentially with log S_ell = order-ell  log(betaomega_mathrmmax). Hence, the error epsilon_L+1(tau) we incur by representing the Green's function in this way and cutting off the sum after L terms does, too. If we know its expansion coefficients, we can easily compute the propagator's Fourier transform by \n\n    hat G(mathrmiomega) = int_0^beta ddtau e^mathrmiomegatau G(tau) approx sum_ell=1^L hat U_ell(mathrmiomega) G_ell\n\nwhere mathrmiomega = (2n+1)mathrmipibeta with n in mathbb Z is a Matsubara frequency. The representation in terms of these expansion coefficients is called the intermediate representation, which SparseIR.jl is concerned with.\n\nTo standardize our variables, we define x in -1+1 and y in -1+1 by\n\n    tau = beta (x+1)2 qand omega = omega_mathrmmax y\n\nso that the kernel can be written\n\n    K(x y) = frace^-Lambda y (x + 1)  2e^-Lambda y + 1\n\nwith Lambda = betaomega_mathrmmax = 80. This is represented by the object LogisticKernel(80.0), which FiniteTempBasis uses internally. (Image: Logistic kernel used to construct the basis in our problem treatment K(x,y).)","category":"section"},{"location":"guide/#Singular-value-expansion","page":"Guide","title":"Singular value expansion","text":"Central is the singular value expansion [5], which is handled by the function SVEResult: Its purpose is to construct the decomposition\n\n    K(x y) approx sum_ell = 0^L U_ell(x) S_ell V_ell(y)\n\nwhere U_ell(x) and V_ell(y) are called K's left and right singular functions respectively and S_ell are its singular values. By construction, the singular functions form an orthonormal basis, i.e.\n\n    int ddx U_ell(x) U_ell(x) = delta_ellell = int ddy V_ell(y) V_ell(y)\n\nand thus above equation is equivalent to a pair of eigenvalue equations\n\nbeginaligned\n    S_ell U_ell(x) = int ddy K(x y) V_ell(y) \n    S_ell V_ell(y) = int ddx K(x y) U_ell(x)\nendaligned\n\nHere and in what follows, unless otherwise indicated, integrals are taken to be over the interval -1+1 (because we rescaled to x and y variables).\n\nThe function first calls the choose_accuracy helper and thereby sets the appropriate working precision. Because we did not specify a working accuracy varepsilon^2, it chooses machine precision eps(Float64), i.e. varepsilon approx 22 times 10^-16 and working type Float64x2 - a 128 bits floating point type provided by the MultiFloats.jl package - because in computing the SVD we incur a precision loss of about half our input bits. This leaves us with full double accuracy results only if we use quad precision during the computation.\nThen - by calling out to the CentrosymmSVE constructor - a support grid x_i times y_j for the kernel to be evaluated later on is built. Along with these support points, weights w_i and z_j are computed. These points and weights consist of repeated scaled Gauss integration rules, such that\n    int ddx f(x) approx sum_i f(x_i) w_i\n    quadtextandquad\n    int ddy g(y) approx sum_j g(y_j) z_j\nTo get an idea regarding the distribution of these sampling points, refer to Fig. 2.2, which shows x_i times y_j for Lambda = 80: (Image: Sampling point distribution resulting from a Cartesian product of Gauss integration rules.)\nNote:\nThe points do not cover -1 1 times -1 1 but only 0 1 times 0 1. This is actually a special case as we exploit the kernel's centrosymmetry, i.e. K(x y) = K(-x -y). It is straightforward to show that the left/right singular vectors then can be chosen as either odd or even functions.\nConsequentially, we actually sample from a reduced kernel K^mathrmred_pm on 0 1 times 0 1 that is given as either\n    K^mathrmred_pm(x y) = K(x y) pm K(x -y)\ngaining a 4-fold speedup (because we take only a quarter of the domain) in constructing the SVE. The full singular functions can be reconstructed by (anti-)symmetrically continuing them to the negative axis. (Image: Reduced kernels, as a function of x and y, parameterizing imaginary time and real frequency, respectively. Compare their [0,1] × [0,1] subregions with the sampling point distribution plot above.)\nUsing the integration rules allows us to approximate\nbeginaligned\n    S_ell U_ell(x_i) approx sum_j K(x_i y_j) V_ell(y_j) z_j forall i \n    S_ell V_ell(y_j) approx sum_i K(x_i y_j) U_ell(x_i) w_i forall j\nendaligned\nwhich we now multiply by sqrtw_i and sqrtz_j respectively to normalize our basis functions, yielding\nbeginaligned\n    S_ell sqrtw_i U_ell(x_i) approx sum_j sqrtw_i K(x_i y_j) sqrtz_j sqrtz_j V_ell(y_j) \n    S_ell sqrtz_j V_ell(y_j) approx sum_i sqrtw_i K(x_i y_j) sqrtz_j sqrtw_i U_ell(x_i)\nendaligned\nIf we now define vectors vec u_ell, vec v_ell and a matrix K with entries u_ell i equiv sqrtw_i U_ell(x_i), v_ell j equiv sqrtz_j V_ell(y_j) and K_ij equiv sqrtw_i K(x_i y_j) sqrtz_j, we obtain\nbeginaligned\n    S_ell u_ell i approx sum_j K_ij v_ell j \n    S_ell v_ell j approx sum_i K_ij u_ell i\nendaligned\nor\nbeginaligned\n    S_ell vec u_ell approx K^phantommathrmT vec v_ell \n    S_ell vec v_ell approx K^mathrmT vec u_ell\nendaligned\nTogether with the property vec u_ell^mathrmT vec u_ell approx delta_ellell approx vec v_ell^mathrmT vec v_ell we have successfully translated the original SVE problem into an SVD, because\n    K = sum_ell S_ell vec u_ell vec v_ell^mathrmT\nThe next step is calling the matrices function which computes the matrix K derived in the previous step.\nnote: Note\nThe function is named in the plural because in the centrosymmetric case it actually returns two matrices K_+ and K_-, one for the even and one for the odd kernel. The SVDs of these matrices are later concatenated, so for simplicity, we will refer to K from here on out.\ninfo: Info\nSpecial care is taken here to avoid FP-arithmetic cancellation around x = -1 and x = +1.\n(Image: Kernel matrices, rotated 90 degrees counterclockwise to make the connection with the (subregion [0,1] × [0,1] of the) previous figure more obvious. Thus we can see how the choice of sampling points has magnified and brought to the matrices' centers the regions of interest. Furthermore, elements with absolute values smaller than 10\\% of the maximum have been omitted to emphasize the structure; this should however not be taken to mean that there is any sparsity to speak of we could exploit in the next step.)\nTake the truncated singular value decomposition (trSVD) of K, or rather, of K_+ and K_-. We use here a custom trSVD routine written by Markus Wallerberger which combines a homemade rank-revealing QR decomposition with GenericLinearAlgebra.svd!. This is necessary because there is currently no trSVD for quad precision types available.\nVia the function truncate, we throw away superfluous terms in our expansion. More specifically, we choose the basis size L such that S_ell  S_0  varepsilon for all ell leq L. Here varepsilon is our selected precision, in our case it's equal to the double precision machine epsilon, 2^-52 approx 222 times 10^-16.\nFinally, we need a postprocessing step implemented in postprocess which performs some technical manipulation to turn the SVD result into the SVE we actually want. The functions are represented as piecewise Legendre polynomials, which model a function on the interval x_mathrmmin x_mathrmmax as a set of segments on the intervals a_i a_i+1, where on each interval the function is expanded in scaled Legendre polynomials. The interval endpoints are chosen such that they reflect the approximate position of roots of a high-order singular function in x.","category":"section"},{"location":"guide/#Finishing-touches","page":"Guide","title":"Finishing touches","text":"The difficult part of constructing the FiniteTempBasis is now over. Next we truncate the left and right singular functions by discarding U_ell and V_ell with indices ell  L to match the S_ell. The functions are now scaled to imaginary-time and frequency according to\n\n    tau = beta2 (x + 1) qand omega = omega_mathrmmax y\n\nThis means the singular values need to be multiplied by sqrt(beta2)omega_mathrmmax, because K(xy) sqrtdd xdd y = K(tauomega) sqrtddtauddomega. We also add to our basis hatU_ell(mathrmiomega), the Fourier transforms of the left singular functions, defined on the fermionic Matsubara frequencies mathrmiomega = mathrmi(2n+1)betapi (with integer n). This is particularly simple, because the Legendre polynomials' Fourier transforms are known analytically and given by spherical Bessel functions, for which we can rely on Bessels.jl [6].\n\nWe can now take a look at our basis functions to get a feel for them:\n\n(Image: First 6 left singular basis functions on the imaginary-time axis.)\n\n(Image: First 6 right singular basis functions on the frequency axis.)\n\nLooking back at the image of the kernel K(xy) we can imagine how it is reconstructed by multiplying and summing (including a factor S_ell) U_ell(tau) and V_ell(omega). An important property of the left singular functions is interlacing, i.e. U_ell interlaces U_ell+1. A function g with roots alpha_n-1 leq ldots leq alpha_1 interlaces a function f with roots beta_n leq ldots leq beta_1 if\n\n    beta_n leq alpha_n-1 leq beta_n-1 leq ldots leq beta_1\n\nWe will use this property for constructing our sparse sampling set.\n\n(Image: First 8 Fourier transformed basis functions on the Matsubara frequency axis.)\n\nAs for the Matsubara basis functions, we plot only the non-zero components, i.e. mathrmImhat U_ell(mathrmiomega) with odd ell and  mathrmRehat U_ell(mathrmiomega) with even ell.","category":"section"},{"location":"guide/#Constructing-the-samplers","page":"Guide","title":"Constructing the samplers","text":"With our basis complete, we construct sparse sampling objects for fermionic propagators on the imaginary-time axis and on the Matsubara frequency axis.\n\njulia> sτ = TauSampling(basis);\n\njulia> show(sampling_points(sτ))\n[0.018885255323127792, 0.10059312563754808, 0.25218900406693556, 0.4822117319309194, 0.8042299148252774, 1.2376463941125326, 1.8067997157763205, 2.535059399842931, 3.4296355795122793, 4.45886851573216, 5.541131484267839, 6.570364420487721, 7.464940600157068, 8.19320028422368, 8.762353605887466, 9.195770085174722, 9.51778826806908, 9.747810995933065, 9.899406874362452, 9.981114744676873]\n\njulia> siω = MatsubaraSampling(basis; positive_only=true);\n\njulia> show(sampling_points(siω))\nFermionicFreq[FermionicFreq(1), FermionicFreq(3), FermionicFreq(5), FermionicFreq(7), FermionicFreq(9), FermionicFreq(11), FermionicFreq(17), FermionicFreq(27), FermionicFreq(49), FermionicFreq(153)]\n\nBoth functions first determine a suitable set of sampling points on their respective axis. In the case of TauSampling, the sampling points tau_i are chosen as the extrema of the highest-order basis function in imaginary-time; this works because U_ell has exactly ell roots. This turns out to be close to optimal with respect to conditioning for this size (within a few percent). Similarly, MatsubaraSampling chooses sampling points mathrmiomega_n as the (discrete) extrema of the highest-order basis function in Matsubara. By setting positive_only=true, one assumes that functions to be fitted are symmetric in Matsubara frequency, i.e.\n\n    hat G(mathrmiomega) = qty(hat G(-mathrmiomega))^*\n\nIn this case, sparse sampling is performed over non-negative frequencies only, cutting away half of the necessary sampling space, so we get only 10 sampling points instead of the 20 in the imaginary-time case.\n\nThen, both compute design matrices by E^tau_iell = u_ell(tau_i) and E^omega_nell = hatu_ell(iomega_n) as well as their SVDs. We are now able to get the IR basis coefficients of a function that is known on the imaginary-time sampling points by solving the fitting problem\n\n    G_ell = mathrmargmin_G_ell sum_tau_i normG(tau_i) - sum_ell E^tau_iell G_ell^2\n\nwhich can be done efficiently once the SVD is known. The same can be done on the Matsubara axis\n\n    G_ell = mathrmargmin_G_ell sum_mathrmiomega_n normhatG(mathrmiomega_n) - sum_ell E^omega_nell G_ell^2\n\nand taken together we now have a way of moving efficiently between both. In solving these problems, we need to take their conditioning into consideration; in the case of the Matsubara axis, the problem is somewhat worse conditioned than on the imaginary-time axis due to its discrete nature. We augment it therefore with 4 additional sampling frequencies.\n\n(Image: Scaling behavior of the fitting problem conditioning.)","category":"section"},{"location":"guide/#Initializing-the-iteration","page":"Guide","title":"Initializing the iteration","text":"Because the non-interacting density of states is given rho_0(omega) = frac2pisqrt1 - omega^2, we can easily get the IR basis coefficients for the non-interacting propagator\n\n    G_0_ell = -S_ell rho_0_ell = -S_ell int ddomega V_ell(omega) rho_0(omega)\n\nby utilizing the overlap function, which implements integration.\n\njulia> U = 1.2\n1.2\n\njulia> ρ₀(ω) = 2/π * √(1 - clamp(ω, -1, +1)^2)\nρ₀ (generic function with 1 method)\n\njulia> ρ₀l = overlap.(basis.v, ρ₀)\n20-element Vector{Float64}:\n  0.601244316541724\n  1.3444106938820255e-17\n -0.3114509472896204\n  ⋮\n -4.553649124439119e-18\n -0.04700635138837371\n  1.734723475976807e-18\n\njulia> G₀l = -basis.s .* ρ₀l\n20-element Vector{Float64}:\n -0.8663768456323275\n -1.6339906341599403e-17\n  0.23834289781690587\n  ⋮\n  7.045824663886568e-23\n  2.816974873845819e-7\n -3.924512839631511e-24\n\nThe coefficients of the full Green's function are then initialized with those of the non-interacting one. Also, we will need the non-interacting propagator in Matsubara for the Dyson equation, so we evaluate with the MatsubaraSampling object created before.\n\njulia> Gl = copy(G₀l)\n20-element Vector{Float64}:\n -0.8663768456323275\n -1.6339906341599403e-17\n  ⋮\n  2.816974873845819e-7\n -3.924512839631511e-24\n\njulia> Σl = zero(Gl)\n20-element Vector{ComplexF64}:\n 0.0 + 0.0im\n 0.0 + 0.0im\n     ⋮\n 0.0 + 0.0im\n 0.0 + 0.0im\n\njulia> Gl_prev = zero(Gl)\n20-element Vector{Float64}:\n 0.0\n 0.0\n ⋮\n 0.0\n 0.0\n\njulia> G₀iω = evaluate(siω, G₀l)\n10-element Vector{ComplexF64}:\n 1.0546844383198476e-16 - 1.468055523701327im\n 1.6747120525708993e-16 - 0.8633270688082162im\n                        ⋮\n  1.627612150170272e-17 - 0.06489281188294724im\n  6.134766817544449e-19 - 0.020802317001514643im","category":"section"},{"location":"guide/#Self-consistency-loop","page":"Guide","title":"Self-consistency loop","text":"We are now ready to tackle the coupled equations from the start, and will restate them here for the reader's convenience:\n\n    Sigma(tau) = U^2 pqtyG(tau)^3\n\nand the Dyson equation\n\n    hat G(mathrmiomega) = pqtypqtyhat G_0(mathrmiomega)^-1 - hatSigma(mathrmiomega)^-1\n\nThe first one is diagonal in tau and the second is diagonal in mathrmiomega, so we employ the IR basis to efficiently convert between the two bases. Starting with our approximation to G_ell we evaluate in the tau-basis to get G(tau), from which we can compute the self-energy on the sampling points Sigma(tau) according to the first equation. This can now be fitted to the tau-basis to get Sigma_ell, and from there hatSigma(mathrmiomega) via evaluation in the mathrmiomega-basis. Now the Dyson equation is used to get hat G(mathrmiomega) on the sampling frequencies, which is then fitted to the mathrmiomega-basis yielding G_ell and completing the loop. This is now performed until convergence.\n\njulia> while !isapprox(Gl, Gl_prev, rtol=ε)\n           Gl_prev = copy(Gl)\n           Gτ = evaluate(sτ, Gl)\n           Στ = @. U^2 * Gτ^3\n           Σl = fit(sτ, Στ)\n           Σiω = evaluate(siω, Σl)\n           Giω = @. (G₀iω^-1 - Σiω)^-1\n           Gl = fit(siω, Giω)\n       end\n\nThis is what one iteration looks like spelled out in equations:\n\nbeginaligned\n    G^mathrmprev_ell = G_ell \n    G(tau_i) = sum_ell U_ell(tau_i) G_ell \n    Sigma(tau_i) = U^2 pqtyG(tau_i)^3 \n    Sigma_ell = mathrmargmin_Sigma_ell sum_tau_i normSigma(tau_i) - sum_ell U_ell(tau_i) Sigma_ell^2 \n    hatSigma(mathrmiomega_n) = sum_ell hat U_ell(mathrmiomega_n) Sigma_ell \n    hat G(mathrmiomega_n) = pqtypqtyhat G_0(mathrmiomega_n)^-1 - hatSigma(mathrmiomega_n)^-1 \n    G_ell = mathrmargmin_G_ell sum_mathrmiomega_n normhat G(mathrmiomega_n) - sum_ell hat U_ell(mathrmiomega_n) G_ell^2\nendaligned\n\nWe consider the iteration converged when the difference between subsequent iterations does not exceed the basis accuracy, i.e. when\n\n    normG_ell - G^mathrmprev_ell leq varepsilon maxBqtynormG_ell normG^mathrmprev_ell\n\nwhere the norm is normG_ell^2 = sum_ell=1^L G_ell^2.\n\nThe entire script, as presented in Appendix: Optimized script, takes around 60ms to run on a laptop CPU from 2019 (Intel Core i7-9750H) and allocates roughly 19MB in the process.","category":"section"},{"location":"guide/#Visualizing-the-solution","page":"Guide","title":"Visualizing the solution","text":"To plot our solution for the self-energy, we create a MatsubaraSampling object on a dense box of sampling frequencies. In this case, we only need it for expanding, i.e. multiplying a vector, hence there is no need for constructing the SVD, so we pass factorize=false.\n\njulia> box = FermionicFreq.(1:2:79)\n40-element Vector{FermionicFreq}:\n  π/β\n  3π/β\n                 ⋮\n 77π/β\n 79π/β\n\njulia> siω_box = MatsubaraSampling(basis; sampling_points=box, factorize=false);\n\njulia> Σiω_box = evaluate(siω_box, Σl)\n40-element Vector{ComplexF64}:\n -6.067770915322836e-17 - 0.09325923974719101im\n 2.0279596075077236e-17 - 0.1225916020773678im\n                        ⋮\n -6.624594477591435e-17 - 0.014786512975659354im\n  -7.08391512971528e-17 - 0.01441676347590391im\n\nWe are now in a position to visualize the results of our calculation in Fig 2.9:\n\nIn the main plot, the imaginary part of the self-energy in Matsubara alongside the sampling points on which it was computed. This illustrates very nicely one of the main advantages of our method: During the entire course of the iteration we only ever need to store and calculate the values of all functions on the sparse set of sampling points and are still able to expand the result on a dense frequency set in the end.\nIn the inset, the IR basis coefficients of the self-energy and of the propagator are shown, along with the basis singular values. We only plot the non-vanishing basis coefficients, which are those at odd values of ell because the real parts of hat G(mathrmiomega) and hat Sigma(mathrmiomega) are almost zero. The singular values S_ellS_1 are the bound for absG_l  G_1 and absSigma_ell  Sigma_1.\n\n(Image: Self-energy calculated in the self-consistency iteration. The inset shows the IR basis coefficients corresponding to the self-energy and the propagator.)","category":"section"},{"location":"guide/#Summary-and-outlook","page":"Guide","title":"Summary and outlook","text":"We introduced SparseIR.jl, a full featured implementation of the intermediate representation in the Julia programming language. By means of a simple example, we explained in detail how to use it and the way it works internally. In this example, we solved an Anderson impurity model with elliptical density of states to second order perturbation theory in the interaction via a self-consistent loop. We successfully obtained the self-energy (accurate to second order) with minimal computational effort.\n\nRegarding further work, perhaps the single most obvious direction is the extension to multi-particle quantities; And indeed, Refs. [7, 8] did exactly this, with Markus Wallerberger writing the as of yet unpublished Julia library OvercompleteIR.jl which builds upon SparseIR.jl. So, as a transitive dependency, the library of the present thesis has already found applications in solving the parquet equations for the Hubbard model and for the Anderson impurity model [9].","category":"section"},{"location":"guide/#References","page":"Guide","title":"References","text":"H. Shinaoka, J. Otsuki, M. Ohzeki and K. Yoshimi. Compressing Green's function using intermediate representation between imaginary-time and real-frequency domains. Physical Review B 96, 35147 (2017).\n\n\n\nJ. Li, M. Wallerberger, N. Chikano, C.-N. Yeh, E. Gull and H. Shinaoka. Sparse sampling approach to efficient ab initio calculations at finite temperature. Physical Review B 101, 035144 (2020).\n\n\n\nH. Shinaoka, N. Chikano, E. Gull, J. Li, T. Nomoto, J. Otsuki, M. Wallerberger, T. Wang and K. Yoshimi. Efficient ab initio many-body calculations based on sparse modeling of Matsubara Green's function. SciPost Phys. Lect. Notes, 63 (2022).\n\n\n\nM. Wallerberger, S. Badr, S. Hoshino, S. Huber, F. Kakizawa, T. Koretsune, Y. Nagai, K. Nogaki, T. Nomoto, H. Mori, J. Otsuki, S. Ozaki, T. Plaikner, R. Sakurai, C. Vogel, N. Witt, K. Yoshimi and H. Shinaoka, sparse-ir: Optimal compression and sparse sampling of many-body propagators. SoftwareX 21, 101266 (2023-02).\n\n\n\nP. C. Hansen. Discrete Inverse Problems: Insights and Algorithms (SIAM, 2010).\n\n\n\nM. Helton and O. Smith. Bessels.jl (2022).\n\n\n\nH. Shinaoka, J. Otsuki, K. Haule, M. Wallerberger, E. Gull, K. Yoshimi and M. Ohzeki. Overcomplete compact representation of two-particle Green's functions. Physical Review B 97, 205111 (2018-05).\n\n\n\nM. Wallerberger, H. Shinaoka and A. Kauch. Solving the Bethe-Salpeter equation with exponential convergence. Physical Review Research 3, 033168 (2021-08).\n\n\n\nM. Michalek. Solving the Anderson impurity model with intermediate representation of the parquet equations (2024). Bachelor's thesis, TU Wien.\n\n\n\n","category":"section"},{"location":"guide/#optimized-script","page":"Guide","title":"Appendix: Optimized script","text":"With minimal modifications we can transform our code to be more optimized for performance:\n\nPut script in a function. This is because globals are type instable in Julia.\nAdd ::Vector{Float64} annotation to ensure type inferrability of ρ₀l.\nGl in the loop will be a Vector{ComplexF64} in the loop, so make it complex right away for type stability.\nPreallocate and reuse arrays to remove allocations in the loop, minimizing total allocations and time spent garbage collecting. Here we benefit from SparseIR.jl providing in-place variants fit! and evaluate!.\n\nusing SparseIR\n\nfunction main(; β=10.0, ωmax=8.0, ε=1e-6)\n    # Construct the IR basis and sparse sampling for fermionic propagators\n    basis = FiniteTempBasis{Fermionic}(β, ωmax, ε)\n    sτ = TauSampling(basis)\n    siω = MatsubaraSampling(basis; positive_only=true)\n\n    # Solve the single impurity Anderson model coupled to a bath with a\n    # semicircular density of states with unit half bandwidth.\n    U = 1.2\n    ρ₀(ω) = 2 / π * √(1 - clamp(ω, -1, +1)^2)\n\n    # Compute the IR basis coefficients for the non-interacting propagator\n    ρ₀l = overlap.(basis.v, ρ₀)::Vector{Float64}\n    G₀l = -basis.s .* ρ₀l\n\n    # Self-consistency loop: alternate between second-order expression for the\n    # self-energy and the Dyson equation until convergence.\n    Gl = complex(G₀l)\n    G₀iω = evaluate(siω, G₀l)\n\n    # Preallocate arrays for the self-energy and the Green's function\n    Σl = similar(Gl)\n    Στ = similar(Gl, ComplexF64, length(sampling_points(sτ)))\n    Σiω = similar(G₀iω)\n    Gτ = similar(Στ)\n    Giω = similar(G₀iω)\n\n    Gl_prev = zero(Gl)\n    while !isapprox(Gl, Gl_prev, rtol=ε)\n        Gl_prev .= Gl\n        evaluate!(Gτ, sτ, Gl)\n        @. Στ = U^2 * Gτ^3\n        fit!(Σl, sτ, Στ)\n        evaluate!(Σiω, siω, Σl)\n        @. Giω = (G₀iω^-1 - Σiω)^-1\n        fit!(Gl, siω, Giω)\n    end\n    return basis, Σl\nend","category":"section"},{"location":"private/#Private-names-index","page":"Private","title":"Private names index","text":"These are not considered API and therefore not covered by any semver promises.","category":"section"},{"location":"private/#Core.Int-Tuple{MatsubaraFreq}","page":"Private","title":"Core.Int","text":"Get prefactor n for the Matsubara frequency ω = n*π/β\n\n\n\n\n\n","category":"method"},{"location":"private/#Core.Integer-Tuple{MatsubaraFreq}","page":"Private","title":"Core.Integer","text":"Get prefactor n for the Matsubara frequency ω = n*π/β\n\n\n\n\n\n","category":"method"},{"location":"private/#SparseIR.AbstractAugmentation","page":"Private","title":"SparseIR.AbstractAugmentation","text":"AbstractAugmentation\n\nScalar function in imaginary time/frequency.\n\nThis represents a single function in imaginary time and frequency, together with some auxiliary methods that make it suitable for augmenting a basis.\n\nSee also: AugmentedBasis\n\n\n\n\n\n","category":"type"},{"location":"private/#SparseIR.AbstractBasis","page":"Private","title":"SparseIR.AbstractBasis","text":"AbstractBasis\n\nAbstract base class for bases on the imaginary-time axis.\n\nLet basis be an abstract basis. Then we can expand a two-point propagator  G(τ), where τ is imaginary time, into a set of basis functions:\n\nG(τ) == sum(basis.u[l](τ) * g[l] for l in 1:length(basis)) + ϵ(τ),\n\nwhere basis.u[l] is the l-th basis function, g[l] is the associated expansion coefficient and ϵ(τ) is an error term. Similarly, the Fourier transform Ĝ(n), where n is now a Matsubara frequency, can be expanded as follows:\n\nĜ(n) == sum(basis.uhat[l](n) * g[l] for l in 1:length(basis)) + ϵ(n),\n\nwhere basis.uhat[l] is now the Fourier transform of the basis function.\n\n\n\n\n\n","category":"type"},{"location":"private/#SparseIR.AbstractKernel","page":"Private","title":"SparseIR.AbstractKernel","text":"AbstractKernel\n\nIntegral kernel K(x, y).\n\nAbstract base type for an integral kernel, i.e. a AbstractFloat binary function K(x y) used in a Fredhold integral equation of the first kind:\n\n    u(x) =  K(x y) v(y) dy\n\nwhere x  x_mathrmmin x_mathrmmax and y  y_mathrmmin y_mathrmmax. For its SVE to exist, the kernel must be square-integrable, for its singular values to decay exponentially, it must be smooth.\n\nIn general, the kernel is applied to a scaled spectral function ρ(y) as:\n\n     K(x y) ρ(y) dy\n\nwhere ρ(y) = w(y) ρ(y).\n\n\n\n\n\n","category":"type"},{"location":"private/#SparseIR.AbstractSVEHints","page":"Private","title":"SparseIR.AbstractSVEHints","text":"AbstractSVEHints\n\nDiscretization hints for singular value expansion of a given kernel.\n\n\n\n\n\n","category":"type"},{"location":"private/#SparseIR.AbstractSampling","page":"Private","title":"SparseIR.AbstractSampling","text":"AbstractSampling\n\nAbstract type for sparse sampling.\n\nEncodes the \"basis transformation\" of a propagator from the truncated IR basis coefficients G_ir[l] to time/frequency sampled on sparse points G(x[i]) together with its inverse, a least squares fit:\n\n     ________________                   ___________________\n    |                |    evaluate     |                   |\n    |     Basis      |---------------->|     Value on      |\n    |  coefficients  |<----------------|  sampling points  |\n    |________________|      fit        |___________________|\n\n\n\n\n\n","category":"type"},{"location":"private/#SparseIR.PiecewiseLegendreFTVector","page":"Private","title":"SparseIR.PiecewiseLegendreFTVector","text":"PiecewiseLegendreFTVector\n\nFourier transform of piecewise Legendre polynomials.\n\nFor a given frequency index n, the Fourier transform of the Legendre function is defined as:\n\n    p̂(n) == ∫ dx exp(im * π * n * x / (xmax - xmin)) p(x)\n\n\n\n\n\n","category":"type"},{"location":"private/#SparseIR.PiecewiseLegendrePoly","page":"Private","title":"SparseIR.PiecewiseLegendrePoly","text":"PiecewiseLegendrePoly <: Function\n\nPiecewise Legendre polynomial.\n\nModels a function on the interval xmin xmax as a set of segments on the intervals Si = ai ai+1, where on each interval the function is expanded in scaled Legendre polynomials.\n\n\n\n\n\n","category":"type"},{"location":"private/#SparseIR.PiecewiseLegendrePolyVector","page":"Private","title":"SparseIR.PiecewiseLegendrePolyVector","text":"PiecewiseLegendrePolyVector\n\nContains a Vector{PiecewiseLegendrePoly}.\n\n\n\n\n\n","category":"type"},{"location":"private/#SparseIR.SVEResult","page":"Private","title":"SparseIR.SVEResult","text":"SVEResult(kernel::AbstractKernel;\n    Twork=nothing, ε=nothing, lmax=typemax(Int),\n    n_gauss=nothing, svd_strat=:auto,\n    sve_strat=iscentrosymmetric(kernel) ? CentrosymmSVE : SamplingSVE\n)\n\nPerform truncated singular value expansion of a kernel.\n\nPerform a truncated singular value expansion (SVE) of an integral kernel kernel : [xmin, xmax] x [ymin, ymax] -> ℝ:\n\nkernel(x, y) == sum(s[l] * u[l](x) * v[l](y) for l in (1, 2, 3, ...)),\n\nwhere s[l] are the singular values, which are ordered in non-increasing fashion, u[l](x) are the left singular functions, which form an orthonormal system on [xmin, xmax], and v[l](y) are the right singular functions, which form an orthonormal system on [ymin, ymax].\n\nThe SVE is mapped onto the singular value decomposition (SVD) of a matrix by expanding the kernel in piecewise Legendre polynomials (by default by using a collocation).\n\nArguments\n\nK::AbstractKernel: Integral kernel to take SVE from.\nϵ::Real: Relative cutoff for the singular values. Only singular values with relative magnitude ≥ cutoff are kept. Defaults to eps(Float64) (≈ 2.22e-16).\ncutoff::Real: Accuracy target for the basis. Controls the precision to which singular values and singular vectors are computed. Defaults to NaN (uses internal default).\nlmax::Integer: Maximum basis size. If given, only at most the lmax most significant singular values and associated singular functions are returned.\n`n_gauss (int): Order of Legendre polynomials. Defaults to kernel hinted value.\nTwork::Integer: Working data type. Defaults to SPIR_TWORK_AUTO which automatically selects the appropriate precision based on the accuracy requirements. Available options:\nSPIR_TWORK_AUTO: Automatically select the best precision (default)\nSPIR_TWORK_FLOAT64: Use double precision (64-bit)\nSPIR_TWORK_FLOAT64X2: Use extended precision (128-bit)\nsve_strat::AbstractSVE: SVE to SVD translation strategy. Defaults to SamplingSVE, optionally wrapped inside of a CentrosymmSVE if the kernel is centrosymmetric.\nsvd_strat ('fast' or 'default' or 'accurate'): SVD solver. Defaults to fast (ID/RRQR) based solution when accuracy goals are moderate, and more accurate Jacobi-based algorithm otherwise.\n\nReturns: An SVEResult containing the truncated singular value expansion.\n\n\n\n\n\n","category":"type"},{"location":"private/#SparseIR.Statistics","page":"Private","title":"SparseIR.Statistics","text":"Statistics(zeta)\n\nAbstract type for quantum statistics (fermionic/bosonic/etc.)\n\n\n\n\n\n","category":"type"},{"location":"private/#SparseIR.accuracy","page":"Private","title":"SparseIR.accuracy","text":"accuracy(basis::AbstractBasis)\n\nAccuracy of the basis.\n\nUpper bound to the relative error of representing a propagator with the given number of basis functions (number between 0 and 1).\n\n\n\n\n\n","category":"function"},{"location":"private/#SparseIR.basis-Tuple{SparseIR.AbstractSampling}","page":"Private","title":"SparseIR.basis","text":"basis(sampling::AbstractSampling)\n\nReturn the IR basis associated with sampling.\n\n\n\n\n\n","category":"method"},{"location":"private/#SparseIR.cover_domain-Tuple{Vector{Float64}, Vararg{Float64, 5}}","page":"Private","title":"SparseIR.cover_domain","text":"cover_domain(knots::Vector{Float64}, xmin::Float64, xmax::Float64, period::Float64, poly_xmin::Float64, poly_xmax::Float64)\n\nGenerate knots that cover the integration domain, handling periodic functions.\n\nThis function extends the basic knots to cover the entire integration domain, taking into account periodicity if applicable.\n\n\n\n\n\n","category":"method"},{"location":"private/#SparseIR.default_matsubara_sampling_points","page":"Private","title":"SparseIR.default_matsubara_sampling_points","text":"default_matsubara_sampling_points(basis::AbstractBasis; positive_only=false)\n\nDefault sampling points on the imaginary frequency axis.\n\nArguments\n\npositive_only::Bool: Only return non-negative frequencies. This is useful if the object to be fitted is symmetric in Matsubura frequency, ĝ(ω) == conj(ĝ(-ω)), or, equivalently, real in imaginary time.\n\n\n\n\n\n","category":"function"},{"location":"private/#SparseIR.default_tau_sampling_points","page":"Private","title":"SparseIR.default_tau_sampling_points","text":"default_tau_sampling_points(basis::AbstractBasis)\n\nDefault sampling points on the imaginary time/x axis.\n\n\n\n\n\n","category":"function"},{"location":"private/#SparseIR.eval_matrix","page":"Private","title":"SparseIR.eval_matrix","text":"eval_matrix(T, basis, x)\n\nReturn evaluation matrix from coefficients to sampling points. T <: AbstractSampling.\n\n\n\n\n\n","category":"function"},{"location":"private/#SparseIR.finite_temp_bases-Tuple{Real, Real, Real}","page":"Private","title":"SparseIR.finite_temp_bases","text":"finite_temp_bases(β::Real, ωmax::Real, ε;\n                  kernel=LogisticKernel(β * ωmax), sve_result=SVEResult(kernel, ε))\n\nConstruct FiniteTempBasis objects for fermion and bosons using the same LogisticKernel instance.\n\nArguments\n\nβ: Inverse temperature (must be positive)\nωmax: Frequency cutoff (must be non-negative)\nε: This parameter controls the number of basis functions. Only singular values ≥ ε * s[1] are kept. Typical values are 1e-6 to 1e-12 depending on the desired accuracy for your calculations. If ε is smaller than the square root of double precision machine epsilon (≈ 1.49e-8), the library will automatically use higher precision for the singular value decomposition, resulting in longer computation time for basis generation.\n\nThe number of basis functions grows logarithmically as log(1/ε) log (β * ωmax).\n\n\n\n\n\n","category":"method"},{"location":"private/#SparseIR.iswellconditioned-Tuple{SparseIR.AbstractBasis}","page":"Private","title":"SparseIR.iswellconditioned","text":"iswellconditioned(basis::AbstractBasis)\n\nReturns true if the sampling is expected to be well-conditioned.\n\n\n\n\n\n","category":"method"},{"location":"private/#SparseIR.rescale-Union{Tuple{S}, Tuple{FiniteTempBasis{S}, Real}} where S","page":"Private","title":"SparseIR.rescale","text":"rescale(basis::FiniteTempBasis, new_beta)\n\nReturn a basis for different temperature.\n\nCreates a new basis with the same accuracy ε but different temperature. The new kernel is constructed with the same cutoff parameter Λ = β * ωmax, which implies a different UV cutoff ωmax since Λ stays constant.\n\nArguments\n\nbasis: The original basis to rescale\nnew_beta: New inverse temperature\n\nReturns\n\nA new FiniteTempBasis with the same statistics type and accuracy but different temperature.\n\n\n\n\n\n","category":"method"},{"location":"private/#SparseIR.s","page":"Private","title":"SparseIR.s","text":"s(basis::AbstractBasis)\n\nGet the singular values of the basis.\n\n\n\n\n\n","category":"function"},{"location":"private/#SparseIR.significance","page":"Private","title":"SparseIR.significance","text":"significance(basis::AbstractBasis)\n\nReturn vector σ, where 0 ≤ σ[i] ≤ 1 is the significance level of the i-th basis function. If ϵ is the desired accuracy to which to represent a propagator, then any basis function where σ[i] < ϵ can be neglected.\n\nFor the IR basis, we simply have that σ[i] = s[i] / first(s).\n\n\n\n\n\n","category":"function"},{"location":"private/#SparseIR.statistics-Union{Tuple{SparseIR.AbstractBasis{S}}, Tuple{S}} where S<:SparseIR.Statistics","page":"Private","title":"SparseIR.statistics","text":"statistics(basis::AbstractBasis)\n\nQuantum statistic (Statistics instance, Fermionic() or Bosonic()).\n\n\n\n\n\n","category":"method"},{"location":"private/#SparseIR.u","page":"Private","title":"SparseIR.u","text":"u(basis::AbstractBasis)\n\nGet the u basis functions (imaginary time).\n\n\n\n\n\n","category":"function"},{"location":"private/#SparseIR.uhat","page":"Private","title":"SparseIR.uhat","text":"uhat(basis::AbstractBasis)\n\nGet the uhat basis functions (Matsubara frequency).\n\n\n\n\n\n","category":"function"},{"location":"private/#SparseIR.v","page":"Private","title":"SparseIR.v","text":"v(basis::AbstractBasis)\n\nGet the v basis functions (real frequency).\n\n\n\n\n\n","category":"function"},{"location":"private/#SparseIR.value-Tuple{MatsubaraFreq, Real}","page":"Private","title":"SparseIR.value","text":"Get value of the Matsubara frequency ω = n*π/β\n\n\n\n\n\n","category":"method"},{"location":"private/#SparseIR.valueim-Tuple{MatsubaraFreq, Real}","page":"Private","title":"SparseIR.valueim","text":"Get complex value of the Matsubara frequency iω = iπ/β * n\n\n\n\n\n\n","category":"method"},{"location":"private/#SparseIR.zeta-Tuple{MatsubaraFreq}","page":"Private","title":"SparseIR.zeta","text":"Get statistics ζ for Matsubara frequency ω = (2*m+ζ)*π/β\n\n\n\n\n\n","category":"method"},{"location":"private/#SparseIR.Λ","page":"Private","title":"SparseIR.Λ","text":"Λ(basis::AbstractBasis)\nlambda(basis::AbstractBasis)\n\nBasis cutoff parameter, Λ = β * ωmax, or None if not present\n\n\n\n\n\n","category":"function"},{"location":"private/#SparseIR.β-Tuple{SparseIR.AbstractBasis}","page":"Private","title":"SparseIR.β","text":"β(basis::AbstractBasis)\nbeta(basis::AbstractBasis)\n\nInverse temperature of the basis.\n\nReturns the inverse temperature parameter β used in the basis construction.\n\n\n\n\n\n","category":"method"},{"location":"private/#SparseIR.ωmax","page":"Private","title":"SparseIR.ωmax","text":"ωmax(basis::AbstractBasis)\nwmax(basis::AbstractBasis)\n\nReal frequency cutoff or nothing if unscaled basis.\n\n\n\n\n\n","category":"function"},{"location":"public/#Public-names-index","page":"Public","title":"Public names index","text":"","category":"section"},{"location":"public/#SparseIR.AugmentedBasis","page":"Public","title":"SparseIR.AugmentedBasis","text":"AugmentedBasis <: AbstractBasis\n\nAugmented basis on the imaginary-time/frequency axis.\n\nGroups a set of additional functions, augmentations, with a given basis. The augmented functions then form the first basis functions, while the rest is provided by the regular basis, i.e.:\n\nu[l](x) == l < naug ? augmentations[l](x) : basis.u[l-naug](x),\n\nwhere naug = length(augmentations) is the number of added basis functions through augmentation. Similar expressions hold for Matsubara frequencies.\n\nAugmentation is useful in constructing bases for vertex-like quantities such as self-energies [wallerberger2021] and when constructing a two-point kernel that serves as a base for multi-point functions [shinaoka2018].\n\nwarning: Warning\nBases augmented with TauConst and TauLinear tend to be poorly conditioned. Care must be taken while fitting and compactness should be enforced if possible to regularize the problem.While vertex bases, i.e. bases augmented with MatsubaraConst, stay reasonably well-conditioned, it is still good practice to treat the Hartree–Fock term separately rather than including it in the basis, if possible.\n\nSee also: MatsubaraConst for vertex basis [wallerberger2021], TauConst, TauLinear for multi-point [shinaoka2018]\n\n[wallerberger2021]: https://doi.org/10.1103/PhysRevResearch.3.033168\n\n[shinaoka2018]: https://doi.org/10.1103/PhysRevB.97.205111\n\n\n\n\n\n","category":"type"},{"location":"public/#SparseIR.Bosonic","page":"Public","title":"SparseIR.Bosonic","text":"Bosonic statistics.\n\n\n\n\n\n","category":"type"},{"location":"public/#SparseIR.DiscreteLehmannRepresentation","page":"Public","title":"SparseIR.DiscreteLehmannRepresentation","text":"DiscreteLehmannRepresentation(basis::AbstractBasis, poles=nothing)\n\nConstruct a DLR basis from an IR basis.\n\nIf poles is not provided, uses the default omega sampling points from the IR basis.\n\n\n\n\n\n","category":"type"},{"location":"public/#SparseIR.DiscreteLehmannRepresentation-2","page":"Public","title":"SparseIR.DiscreteLehmannRepresentation","text":"DiscreteLehmannRepresentation{S,B} <: AbstractBasis{S}\n\nDiscrete Lehmann representation (DLR) with poles selected according to extrema of IR.\n\nThis type wraps the C API DLR functionality. The DLR basis is a variant of the IR basis that uses a \"sketching\" approach - representing functions as a linear combination of poles on the real-frequency axis:\n\nG(iv) == sum(a[i] / (iv - w[i]) for i in 1:npoles)\n\nFields\n\nptr::Ptr{spir_basis}: Pointer to the C DLR object\nbasis::B: The underlying IR basis\npoles::Vector{Float64}: Pole locations on the real-frequency axis\n\n\n\n\n\n","category":"type"},{"location":"public/#SparseIR.Fermionic","page":"Public","title":"SparseIR.Fermionic","text":"Fermionic statistics.\n\n\n\n\n\n","category":"type"},{"location":"public/#SparseIR.FiniteTempBasis","page":"Public","title":"SparseIR.FiniteTempBasis","text":"FiniteTempBasis <: AbstractBasis\n\nIntermediate representation (IR) basis for given temperature.\n\nFor a continuation kernel K from real frequencies, ω ∈ [-ωmax, ωmax], to imaginary time, τ ∈ [0, β], this type stores the truncated singular value expansion or IR basis:\n\nK(τ, ω) ≈ sum(u[l](τ) * s[l] * v[l](ω) for l in 1:L)\n\nThis basis is inferred from a reduced form by appropriate scaling of the variables.\n\nFields\n\nu::PiecewiseLegendrePolyVector: Set of IR basis functions on the imaginary time (tau) axis. These functions are stored as piecewise Legendre polynomials.\nTo obtain the value of all basis functions at a point or a array of points x, you can call the function u(x). To obtain a single basis function, a slice or a subset l, you can use u[l].\nuhat::PiecewiseLegendreFTVector: Set of IR basis functions on the Matsubara frequency (wn) axis. These objects are stored as a set of Bessel functions.\nTo obtain the value of all basis functions at a Matsubara frequency or a array of points wn, you can call the function uhat(wn). Note that we expect reduced frequencies, which are simply even/odd numbers for bosonic/fermionic objects. To obtain a single basis function, a slice or a subset l, you can use uhat[l].\ns: Vector of singular values of the continuation kernel\nv::PiecewiseLegendrePolyVector: Set of IR basis functions on the real frequency (w) axis. These functions are stored as piecewise Legendre polynomials.\nTo obtain the value of all basis functions at a point or a array of points w, you can call the function v(w). To obtain a single basis function, a slice or a subset l, you can use v[l].\n\n\n\n\n\n","category":"type"},{"location":"public/#SparseIR.FiniteTempBasis-Union{Tuple{S}, Tuple{Real, Real, Real}} where S<:SparseIR.Statistics","page":"Public","title":"SparseIR.FiniteTempBasis","text":"FiniteTempBasis{S}(β, ωmax, ε; kernel=LogisticKernel(β * ωmax), sve_result=SVEResult(kernel, ε), max_size=-1)\n\nConstruct a finite temperature basis suitable for the given S (Fermionic or Bosonic) and cutoffs β and ωmax.\n\nArguments\n\nβ: Inverse temperature (must be positive)\nωmax: Frequency cutoff (must be non-negative)\nε: This parameter controls the number of basis functions. Only singular values ≥ ε * s[1] are kept. Typical values are 1e-6 to 1e-12 depending on the desired accuracy for your calculations. If ε is smaller than the square root of double precision machine epsilon (≈ 1.49e-8), the library will automatically use higher precision for the singular value decomposition, resulting in longer computation time for basis generation.\n\nThe number of basis functions grows logarithmically as log(1/ε) log (β * ωmax).\n\n\n\n\n\n","category":"method"},{"location":"public/#SparseIR.FiniteTempBasis-Union{Tuple{S}, Tuple{S, Real, Real, Real}} where S<:SparseIR.Statistics","page":"Public","title":"SparseIR.FiniteTempBasis","text":"FiniteTempBasis(stat::Statistics, β, ωmax, ε; kernel=LogisticKernel(β * ωmax), sve_result=SVEResult(kernel, ε), max_size=-1)\n\nConvenience constructor that matches SparseIR.jl signature.\n\nConstruct a finite temperature basis for the given statistics type and cutoffs.\n\nArguments\n\nstat: Statistics type (Fermionic() or Bosonic())\nβ: Inverse temperature (must be positive)\nωmax: Frequency cutoff (must be non-negative)\nε: Accuracy target for the basis. This parameter controls the number of basis functions. Only singular values ≥ ε * s[1] are kept. Typical values are 1e-6 to 1e-12 depending on the desired accuracy for your calculations. If ε is smaller than the square root of double precision machine epsilon (≈ 1.49e-8), the library will automatically use higher precision for the singular value decomposition, resulting in longer computation time for basis generation.\n\nThe number of basis functions grows logarithmically as log(1/ε) log (β * ωmax).\n\n\n\n\n\n","category":"method"},{"location":"public/#SparseIR.FiniteTempBasisSet","page":"Public","title":"SparseIR.FiniteTempBasisSet","text":"FiniteTempBasisSet\n\nType for holding IR bases and sparse-sampling objects.\n\nAn object of this type holds IR bases for fermions and bosons and associated sparse-sampling objects.\n\nFields\n\nbasis_f::FiniteTempBasis: Fermion basis\nbasis_b::FiniteTempBasis: Boson basis\ntau::Vector{Float64}: Sampling points in the imaginary-time domain\nwn_f::Vector{Int}: Sampling fermionic frequencies\nwn_b::Vector{Int}: Sampling bosonic frequencies\nsmpltauf::TauSampling: Sparse sampling for tau & fermion\nsmpltaub::TauSampling: Sparse sampling for tau & boson\nsmplwnf::MatsubaraSampling: Sparse sampling for Matsubara frequency & fermion\nsmplwnb::MatsubaraSampling: Sparse sampling for Matsubara frequency & boson\nsve_result::Tuple{PiecewiseLegendrePoly,Vector{Float64},PiecewiseLegendrePoly}: Results of SVE\n\nGetters\n\nbeta::Float64: Inverse temperature\nωmax::Float64: Cut-off frequency\n\n\n\n\n\n","category":"type"},{"location":"public/#SparseIR.LogisticKernel","page":"Public","title":"SparseIR.LogisticKernel","text":"LogisticKernel <: AbstractKernel\n\nFermionic/bosonic analytical continuation kernel.\n\nIn dimensionless variables x = 2 τβ - 1, y = β ωΛ, the integral kernel is a function on -1 1  -1 1:\n\n    K(x y) = frace^-Λ y (x + 1)  21 + e^-Λ y\n\nLogisticKernel is a fermionic analytic continuation kernel. Nevertheless, one can model the τ dependence of a bosonic correlation function as follows:\n\n     frace^-Λ y (x + 1)  21 - e^-Λ y ρ(y) dy =  K(x y) ρ(y) dy\n\nwith\n\n    ρ(y) = w(y) ρ(y)\n\nwhere the weight function is given by\n\n    w(y) = frac1tanh(Λ y2)\n\n\n\n\n\n","category":"type"},{"location":"public/#SparseIR.MatsubaraConst","page":"Public","title":"SparseIR.MatsubaraConst","text":"MatsubaraConst <: AbstractAugmentation\n\nConstant in Matsubara, undefined in imaginary time.\n\n\n\n\n\n","category":"type"},{"location":"public/#SparseIR.MatsubaraFreq","page":"Public","title":"SparseIR.MatsubaraFreq","text":"MatsubaraFreq(n)\n\nPrefactor n of the Matsubara frequency ω = n*π/β\n\nStruct representing the Matsubara frequency ω entering the Fourier transform of a propagator G(τ) on imaginary time τ to its Matsubara equivalent Ĝ(iω) on the imaginary-frequency axis:\n\n        β\nĜ(iω) = ∫  dτ exp(iωτ) G(τ)      with    ω = n π/β,\n        0\n\nwhere β is inverse temperature and by convention we include the imaginary unit in the frequency argument, i.e, Ĝ(iω). The frequencies depend on the statistics of the propagator, i.e., we have that:\n\nG(τ - β) = ± G(τ)\n\nwhere + is for bosons and - is for fermions. The frequencies are restricted accordingly.\n\nBosonic frequency (S == Fermionic): n even (periodic in β)\nFermionic frequency (S == Bosonic): n odd (anti-periodic in β)\n\n\n\n\n\n","category":"type"},{"location":"public/#SparseIR.MatsubaraSampling","page":"Public","title":"SparseIR.MatsubaraSampling","text":"MatsubaraSampling{T,B} <: AbstractSampling\n\nSparse sampling in Matsubara frequencies using the C API.\n\nAllows transformation between IR basis coefficients and sampling points in Matsubara frequencies.\n\n\n\n\n\n","category":"type"},{"location":"public/#SparseIR.MatsubaraSampling-Tuple{SparseIR.AbstractBasis}","page":"Public","title":"SparseIR.MatsubaraSampling","text":"MatsubaraSampling(basis::AbstractBasis; positive_only=false, sampling_points=nothing, factorize=true)\n\nConstruct a MatsubaraSampling object from a basis. If sampling_points is not provided, the default Matsubara sampling points from the basis are used.\n\nIf positive_only=true, assumes functions are symmetric in Matsubara frequency.\n\n\n\n\n\n","category":"method"},{"location":"public/#SparseIR.RegularizedBoseKernel","page":"Public","title":"SparseIR.RegularizedBoseKernel","text":"RegularizedBoseKernel <: AbstractKernel\n\nRegularized bosonic analytical continuation kernel.\n\nIn dimensionless variables x = 2 τβ - 1, y = β ωΛ, the fermionic integral kernel is a function on -1 1  -1 1:\n\n    K(x y) = y frace^-Λ y (x + 1)  2e^-Λ y - 1\n\nCare has to be taken in evaluating this expression around y = 0.\n\n\n\n\n\n","category":"type"},{"location":"public/#SparseIR.TauConst","page":"Public","title":"SparseIR.TauConst","text":"TauConst <: AbstractAugmentation\n\nConstant in imaginary time/discrete delta in frequency.\n\n\n\n\n\n","category":"type"},{"location":"public/#SparseIR.TauLinear","page":"Public","title":"SparseIR.TauLinear","text":"TauLinear <: AbstractAugmentation\n\nLinear function in imaginary time, antisymmetric around β/2.\n\n\n\n\n\n","category":"type"},{"location":"public/#SparseIR.TauSampling","page":"Public","title":"SparseIR.TauSampling","text":"TauSampling{T,B} <: AbstractSampling\n\nSparse sampling in imaginary time using the C API.\n\nAllows transformation between IR basis coefficients and sampling points in imaginary time.\n\n\n\n\n\n","category":"type"},{"location":"public/#SparseIR.TauSampling-Tuple{SparseIR.AbstractBasis}","page":"Public","title":"SparseIR.TauSampling","text":"TauSampling(basis::AbstractBasis; sampling_points=nothing, use_positive_taus=true)\n\nConstruct a TauSampling object from a basis. If sampling_points is not provided, the default tau sampling points from the basis are used.\n\nIf use_positive_taus=true, the sampling points are folded to the positive tau domain [0, β) [default].\n\nIf use_positive_taus=false, the sampling points are in the range [-β/2, β/2].\n\n\n\n\n\n","category":"method"},{"location":"public/#SparseIR.default_omega_sampling_points-Tuple{SparseIR.AbstractBasis}","page":"Public","title":"SparseIR.default_omega_sampling_points","text":"default_omega_sampling_points(basis::AbstractBasis)\n\nGet the default real-frequency sampling points for a basis.\n\nThese are the extrema of the highest-order basis function on the real-frequency axis, which provide near-optimal conditioning for the DLR.\n\n\n\n\n\n","category":"method"},{"location":"public/#SparseIR.evaluate!-Union{Tuple{N}, Tuple{Tin}, Tuple{Tout}, Tuple{Array{Tout, N}, TauSampling, Array{Tin, N}}} where {Tout, Tin, N}","page":"Public","title":"SparseIR.evaluate!","text":"evaluate!(output::Array, sampling::AbstractSampling, al::Array; dim=1)\n\nIn-place version of evaluate. Write results to the pre-allocated output array.\n\n\n\n\n\n","category":"method"},{"location":"public/#SparseIR.evaluate-Union{Tuple{N}, Tuple{T}, Tuple{Union{MatsubaraSampling, TauSampling}, Array{T, N}}} where {T, N}","page":"Public","title":"SparseIR.evaluate","text":"evaluate(sampling::AbstractSampling, al::Array; dim=1)\n\nEvaluate basis coefficients at the sampling points using the C API.\n\nFor multidimensional arrays, dim specifies which dimension corresponds to the basis coefficients.\n\n\n\n\n\n","category":"method"},{"location":"public/#SparseIR.fit!-Union{Tuple{N}, Tuple{Tin}, Tuple{Tout}, Tuple{Array{Tout, N}, TauSampling, Array{Tin, N}}} where {Tout, Tin, N}","page":"Public","title":"SparseIR.fit!","text":"fit!(output::Array, sampling::AbstractSampling, al::Array; dim=1)\n\nIn-place version of fit. Write results to the pre-allocated output array.\n\n\n\n\n\n","category":"method"},{"location":"public/#SparseIR.fit-Union{Tuple{N}, Tuple{T}, Tuple{Union{MatsubaraSampling, TauSampling}, Array{T, N}}} where {T, N}","page":"Public","title":"SparseIR.fit","text":"fit(sampling::AbstractSampling, al::Array; dim=1)\n\nFit basis coefficients from values at sampling points using the C API.\n\nFor multidimensional arrays, dim specifies which dimension corresponds to the sampling points.\n\n\n\n\n\n","category":"method"},{"location":"public/#SparseIR.from_IR-Union{Tuple{N}, Tuple{T}, Tuple{DiscreteLehmannRepresentation, Array{T, N}}, Tuple{DiscreteLehmannRepresentation, Array{T, N}, Any}} where {T, N}","page":"Public","title":"SparseIR.from_IR","text":"from_IR(dlr::DiscreteLehmannRepresentation, gl::Array, dims=1)\n\nTransform from IR basis coefficients to DLR coefficients.\n\nArguments\n\ndlr: The DLR basis\ngl: IR basis coefficients\ndims: Dimension along which the basis coefficients are stored\n\nReturns\n\nDLR coefficients with the same shape as input, but with size length(dlr) along dimension dims.\n\n\n\n\n\n","category":"method"},{"location":"public/#SparseIR.get_poles-Tuple{DiscreteLehmannRepresentation}","page":"Public","title":"SparseIR.get_poles","text":"get_poles(dlr::DiscreteLehmannRepresentation)\n\nGet the pole locations for the DLR basis.\n\nReturns a vector of pole locations on the real-frequency axis.\n\n\n\n\n\n","category":"method"},{"location":"public/#SparseIR.iscentrosymmetric-Tuple{SparseIR.AbstractKernel}","page":"Public","title":"SparseIR.iscentrosymmetric","text":"iscentrosymmetric(kernel::AbstractKernel)\n\nReturn whether the kernel satisfies K(x, y) == K(-x, -y) for all values of x and y. Defaults to false.\n\nA centrosymmetric kernel can be block-diagonalized, speeding up the singular value expansion by a factor of 4.\n\n\n\n\n\n","category":"method"},{"location":"public/#SparseIR.npoints-Tuple{Union{MatsubaraSampling, TauSampling}}","page":"Public","title":"SparseIR.npoints","text":"npoints(sampling::AbstractSampling)\n\nGet the number of sampling points.\n\n\n\n\n\n","category":"method"},{"location":"public/#SparseIR.npoles-Tuple{DiscreteLehmannRepresentation}","page":"Public","title":"SparseIR.npoles","text":"npoles(dlr::DiscreteLehmannRepresentation)\n\nGet the number of poles in the DLR basis.\n\n\n\n\n\n","category":"method"},{"location":"public/#SparseIR.overlap-Union{Tuple{F}, Tuple{SparseIR.PiecewiseLegendrePoly, F, Float64, Float64}} where F","page":"Public","title":"SparseIR.overlap","text":"overlap(poly::PiecewiseLegendrePoly, f, xmin::Float64, xmax::Float64; \n    rtol=eps(), return_error=false, maxevals=10^4, points=Float64[])\n\nEvaluate overlap integral of poly with arbitrary function f.\n\nGiven the function f, evaluate the integral\n\n∫ dx f(x) poly(x)\n\nusing adaptive Gauss-Legendre quadrature.\n\npoints is a sequence of break points in the integration interval where local difficulties of the integrand may occur (e.g. singularities, discontinuities).\n\n\n\n\n\n","category":"method"},{"location":"public/#SparseIR.overlap-Union{Tuple{F}, Tuple{SparseIR.PiecewiseLegendrePoly, F}} where F","page":"Public","title":"SparseIR.overlap","text":"overlap(poly::PiecewiseLegendrePoly, f; \n    rtol=eps(), return_error=false, maxevals=10^4, points=Float64[])\n\nEvaluate overlap integral of poly with arbitrary function f using default range.\n\nGiven the function f, evaluate the integral\n\n∫ dx f(x) poly(x)\n\nusing adaptive Gauss-Legendre quadrature with the default integration range.\n\npoints is a sequence of break points in the integration interval where local difficulties of the integrand may occur (e.g. singularities, discontinuities).\n\n\n\n\n\n","category":"method"},{"location":"public/#SparseIR.overlap-Union{Tuple{F}, Tuple{SparseIR.PiecewiseLegendrePolyVector, F}} where F","page":"Public","title":"SparseIR.overlap","text":"overlap(polys::PiecewiseLegendrePolyVector, f; \n    rtol=eps(), return_error=false, maxevals=10^4, points=Float64[])\n\nEvaluate overlap integral of polys with arbitrary function f using default range.\n\nGiven the function f, evaluate the integral\n\n∫ dx f(x) polys[i](x)\n\nfor each polynomial in the vector using adaptive Gauss-Legendre quadrature with the default integration range.\n\n\n\n\n\n","category":"method"},{"location":"public/#SparseIR.sampling_points-Tuple{SparseIR.AbstractSampling}","page":"Public","title":"SparseIR.sampling_points","text":"sampling_points(sampling::AbstractSampling)\n\nReturn sampling points.\n\n\n\n\n\n","category":"method"},{"location":"public/#SparseIR.to_IR-Union{Tuple{N}, Tuple{T}, Tuple{DiscreteLehmannRepresentation, Array{T, N}}, Tuple{DiscreteLehmannRepresentation, Array{T, N}, Any}} where {T, N}","page":"Public","title":"SparseIR.to_IR","text":"to_IR(dlr::DiscreteLehmannRepresentation, g_dlr::Array, dims=1)\n\nTransform from DLR coefficients to IR basis coefficients.\n\nArguments\n\ndlr: The DLR basis\ng_dlr: DLR coefficients\ndims: Dimension along which the DLR coefficients are stored\n\nReturns\n\nIR basis coefficients with the same shape as input, but with size length(dlr.basis) along dimension dims.\n\n\n\n\n\n","category":"method"},{"location":"#SparseIR.jl","page":"Home","title":"SparseIR.jl","text":"Documentation for SparseIR.jl.\n\nThere is a guide available which details SparseIR.jl's inner workings by means of a worked example.\n\nFor listings of all documented names, see Public names index and the Private names index.","category":"section"}]
}
