<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Guide · SparseIR.jl</title><meta name="title" content="Guide · SparseIR.jl"/><meta property="og:title" content="Guide · SparseIR.jl"/><meta property="twitter:title" content="Guide · SparseIR.jl"/><meta name="description" content="Documentation for SparseIR.jl."/><meta property="og:description" content="Documentation for SparseIR.jl."/><meta property="twitter:description" content="Documentation for SparseIR.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SparseIR.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Guide</a><ul class="internal"><li><a class="tocitem" href="#Problem-statement"><span>Problem statement</span></a></li><li><a class="tocitem" href="#outline"><span>Outline</span></a></li><li class="toplevel"><a class="tocitem" href="#Treatment"><span>Treatment</span></a></li><li><a class="tocitem" href="#Basis-construction"><span>Basis construction</span></a></li><li><a class="tocitem" href="#Constructing-the-samplers"><span>Constructing the samplers</span></a></li><li><a class="tocitem" href="#Initializing-the-iteration"><span>Initializing the iteration</span></a></li><li><a class="tocitem" href="#Self-consistency-loop"><span>Self-consistency loop</span></a></li><li><a class="tocitem" href="#Visualizing-the-solution"><span>Visualizing the solution</span></a></li><li class="toplevel"><a class="tocitem" href="#Summary-and-outlook"><span>Summary and outlook</span></a></li><li class="toplevel"><a class="tocitem" href="#References"><span>References</span></a></li><li class="toplevel"><a class="tocitem" href="#optimized-script"><span>Appendix: Optimized script</span></a></li></ul></li><li><a class="tocitem" href="../public/">Public</a></li><li><a class="tocitem" href="../private/">Private</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Guide</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SpM-lab/SparseIR.jl/blob/main/docs/src/guide.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="guide"><a class="docs-heading-anchor" href="#guide">Introduction</a><a id="guide-1"></a><a class="docs-heading-anchor-permalink" href="#guide" title="Permalink"></a></h1><p>We present <code>SparseIR.jl</code>, a Julia library for constructing and working with the intermediate representation of correlation functions [<a href="#Shinaoka2017">1</a>–<a href="#Wallerberger2023">4</a>]. The intermediate representation (IR) takes the matrix kernel transforming propagators between the real-frequency axis and the imaginary-time axis and performs a singular value expansion (SVE) on it. This decomposes the matrix kernel into a set of singular values as well as two sets of functions. One of those lives on the real-frequency axis and one on the imaginary-time axis. Expressing a propagator in terms of either basis–by an ordinary least squares fit–then allows us to easily transition between them. In combination with a prescription for constructing sparse sets of sampling points on each axis, we have a method for optimally compressing propagators.</p><p><code>SparseIR.jl</code> implements the intermediate representation, providing on-the-fly computation of basis functions and singular values accurate to full precision along with routines for sparse sampling. It is further fully unit tested, featuring near-complete code coverage. Here, we will explain its inner structure by means of an example use case. In preparing this document, <code>SparseIR.jl</code> version <code>1.0.18</code> and Julia version <code>1.11.1</code> were used.</p><h2 id="Problem-statement"><a class="docs-heading-anchor" href="#Problem-statement">Problem statement</a><a id="Problem-statement-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-statement" title="Permalink"></a></h2><p>We take a problem to be solved from the <code>sparse-ir</code> paper [<a href="#Wallerberger2023">4</a>].</p><blockquote><p>Let us perform self-consistent second-order perturbation theory for the single impurity Anderson model at finite temperature. Its Hamiltonian is given by</p><p class="math-container">\[    H = U c^\dagger_\uparrow c^\dagger_\downarrow c_\downarrow c_\uparrow + \sum_{p\sigma} \big(V_{p\sigma}  f_{p\sigma}^\dagger c_\sigma + V_{p\sigma}^* c_\sigma^\dagger f_{p\sigma}\big) + \sum_{p\sigma} \epsilon_{p} f_{p\sigma}^\dagger f_{p\sigma}\]</p><p>where <span>$U$</span> is the electron interaction strength, <span>$c_\sigma$</span> annihilates an electron on the impurity, <span>$f_{p\sigma}$</span> annihilates an electron in the bath, <span>$\dagger$</span> denotes the Hermitian conjugate, <span>$p\in\mathbb R$</span> is bath momentum, and <span>$\sigma\in\{\uparrow, \downarrow\}$</span> the spin. The hybridization strength <span>$V_{p\sigma}$</span> and bath energies <span>$\epsilon_p$</span> are chosen such that the non-interacting density of states is semi-elliptic with a half-bandwidth of one, <span>$\rho_0(\omega) = \frac2\pi\sqrt{1-\omega^2}$</span>, <span>$U=1.2$</span>, <span>$\beta=10$</span>, [...]</p></blockquote><h2 id="outline"><a class="docs-heading-anchor" href="#outline">Outline</a><a id="outline-1"></a><a class="docs-heading-anchor-permalink" href="#outline" title="Permalink"></a></h2><p>To provide an overview, we first give the full code used to solve the problem with <code>SparseIR.jl</code>.</p><pre><code class="language-julia hljs">using SparseIR

β = 10.0; ωmax = 8.0; ε = 1e-6;

# Construct the IR basis and sparse sampling for fermionic propagators
basis = FiniteTempBasis{Fermionic}(β, ωmax, ε)
sτ = TauSampling(basis)
siω = MatsubaraSampling(basis; positive_only=true)

# Solve the single impurity Anderson model coupled to a bath with a
# semicircular density of states with unit half bandwidth.
U = 1.2
ρ₀(ω) = 2/π * √(1 - clamp(ω, -1, +1)^2)

# Compute the IR basis coefficients for the non-interacting propagator
ρ₀l = overlap.(basis.v, ρ₀)
G₀l = -basis.s .* ρ₀l

# Self-consistency loop: alternate between second-order expression for the
# self-energy and the Dyson equation until convergence.
Gl = copy(G₀l)
Σl = zero(Gl)
Gl_prev = zero(Gl)
G₀iω = evaluate(siω, G₀l)
while !isapprox(Gl, Gl_prev, rtol=ε)
    Gl_prev = copy(Gl)
    Gτ = evaluate(sτ, Gl)
    Στ = @. U^2 * Gτ^3
    Σl = fit(sτ, Στ)
    Σiω = evaluate(siω, Σl)
    Giω = @. (G₀iω^-1 - Σiω)^-1
    Gl = fit(siω, Giω)
end</code></pre><p>Note that this script as presented is optimized for readability instead of performance; in practice, you would want to make minor adjustments to ensure maximum type inferrability and full type stability, among other things putting the code in a function instead of executing in global scope. Such an performance-optimized version is provided in <a href="#optimized-script">Appendix: Optimized script</a>. The following is a detailed explanation of what happens here under the hood and why.</p><h1 id="Treatment"><a class="docs-heading-anchor" href="#Treatment">Treatment</a><a id="Treatment-1"></a><a class="docs-heading-anchor-permalink" href="#Treatment" title="Permalink"></a></h1><p>If we take the second-order expression for the self-energy, which at half filling is simply </p><p class="math-container">\[    \Sigma(\tau) = U^2 \pqty{G(\tau)}^3\]</p><p>and the Dyson equation</p><p class="math-container">\[    \hat G(\mathrm{i}\omega) = \pqty{\pqty{\hat G_0(\mathrm{i}\omega)}^{-1} - \hat\Sigma(\mathrm{i}\omega)}^{-1}\]</p><p>we have a system of two coupled equations. The first one is diagonal in <span>$\tau$</span> and the second is diagonal in <span>$\mathrm{i}\omega$</span>, so we need a way of converting efficiently between these two axes.</p><h2 id="Basis-construction"><a class="docs-heading-anchor" href="#Basis-construction">Basis construction</a><a id="Basis-construction-1"></a><a class="docs-heading-anchor-permalink" href="#Basis-construction" title="Permalink"></a></h2><p>We first import <code>SparseIR</code> and construct an appropriate basis. To do so, we must first choose an appropriate UV frequency cutoff <span>$\omega_\mathrm{max}$</span>, representing the maximum bandwidth our basis can capture. The non-interacting density of states in our problem is semi-elliptic with half-bandwidth 1. Once we introduce interactions via the interaction strength <span>$U$</span>, this band splits into the lower and the upper Hubbard bands, centered around <span>$\omega = \pm U/2$</span> respectively. So the bandwidth should be around <span>$3.2$</span> at a minimum, but we choose more than twice that with <span>$\omega_\mathrm{max} = 8$</span> to be safe.</p><pre><code class="language-julia-repl hljs">julia&gt; using SparseIR

julia&gt; β = 10.0; ωmax = 8.0; ε = 1e-6;

julia&gt; basis = FiniteTempBasis{Fermionic}(β, ωmax, ε)
20-element FiniteTempBasis{Fermionic} with β = 10.0, ωmax = 8.0 and singular values:
 1.4409730317545617
 1.2153954454510802
 0.7652662478347486
 0.49740673945822533
 0.288562095623106
 0.1639819552743817
 0.08901271087151318
 0.046837974354297436
 0.023857653233506308
 0.01179373309602762
 0.005662400021411787
 0.0026427291749051072
 0.0011996720525663963
 0.0005299554043095754
 0.00022790287514550545
 9.544046906619884e-5
 3.8931895383167936e-5
 1.5472919567017398e-5
 5.992753725069063e-6
 2.2623276239584257e-6</code></pre><p>There is quite a lot happening behind the scenes in this first innocuous-looking statement, so we will break it down:</p><h3 id="Kernel"><a class="docs-heading-anchor" href="#Kernel">Kernel</a><a id="Kernel-1"></a><a class="docs-heading-anchor-permalink" href="#Kernel" title="Permalink"></a></h3><p>Consider a propagator/Green&#39;s function defined on the imaginary-time axis</p><p class="math-container">\[    G(\tau) \equiv -\ev{T_\tau A(\tau) B(0)}\]</p><p>and the associated spectral function in real frequency <span>$\rho(\omega) = -(1/\pi) \;\mathrm{Im}\;G(\omega)$</span>. These are related via</p><p class="math-container">\[    G(\tau) = -\int_{-\omega_\mathrm{max}}^{+\omega_\mathrm{max}} \dd{\omega} \tilde K(\tau, \omega) \rho(\omega)\]</p><p>with the integral kernel</p><p class="math-container">\[    \tilde K(\tau, \omega) = \frac{e^{-\tau\omega}}{e^{-\beta\omega} + 1}\]</p><p>mediating between them. If we perform an SVE on this kernel, yielding the decomposition</p><p class="math-container">\[    \tilde K(\tau, \omega) = \sum_{\ell=1}^\infty U_\ell(\tau) S_\ell V_\ell(\omega),\]</p><p>with the <span>$U_\ell$</span>s and <span>$V_\ell$</span>s each forming an orthonormal system, we can write</p><p class="math-container">\[    G(\tau) = \sum_{\ell=1}^\infty U_\ell(\tau) G_\ell = \sum_{\ell=1}^L U_\ell(\tau) G_\ell + \epsilon_{L+1}(\tau)\]</p><p>with expansion coefficients given by</p><p class="math-container">\[    G_\ell = -\int_{-\omega_\mathrm{max}}^{+\omega_\mathrm{max}} \dd{\omega}  S_\ell V_\ell(\omega) \rho(\omega).\]</p><p>The singular values decay at least exponentially with <span>$\log S_\ell = \order{-\ell / \log(\beta\omega_\mathrm{max})}$</span>. Hence, the error <span>$\epsilon_{L+1}(\tau)$</span> we incur by representing the Green&#39;s function in this way and cutting off the sum after <span>$L$</span> terms does, too. If we know its expansion coefficients, we can easily compute the propagator&#39;s Fourier transform by </p><p class="math-container">\[    \hat G(\mathrm{i}\omega) = \int_0^\beta \dd{\tau} e^{\mathrm{i}\omega\tau} G(\tau) \approx \sum_{\ell=1}^L \hat U_\ell(\mathrm{i}\omega) G_\ell,\]</p><p>where <span>$\mathrm{i}\omega = (2n+1)\mathrm{i}\pi/\beta$</span> with <span>$n \in \mathbb Z$</span> is a Matsubara frequency. The representation in terms of these expansion coefficients is called the intermediate representation, which <code>SparseIR.jl</code> is concerned with.</p><p>To standardize our variables, we define <span>$x \in [-1,+1]$</span> and <span>$y \in [-1,+1]$</span> by</p><p class="math-container">\[    \tau = \beta (x+1)/2 \qand \omega = \omega_\mathrm{max} y\]</p><p>so that the kernel can be written</p><p class="math-container">\[    K(x, y) = \frac{e^{-\Lambda y (x + 1) / 2}}{e^{-\Lambda y} + 1},\]</p><p>with <span>$\Lambda = \beta\omega_\mathrm{max} = 80$</span>. This is represented by the object <code>LogisticKernel(80.0)</code>, which <code>FiniteTempBasis</code> uses internally. <img src="../assets/img/kernel.png" alt="Logistic kernel used to construct the basis in our problem treatment K(x,y)."/></p><h3 id="Singular-value-expansion"><a class="docs-heading-anchor" href="#Singular-value-expansion">Singular value expansion</a><a id="Singular-value-expansion-1"></a><a class="docs-heading-anchor-permalink" href="#Singular-value-expansion" title="Permalink"></a></h3><p>Central is the <em>singular value expansion</em> [<a href="#Hansen2010">5</a>], which is handled by the function <code>SVEResult</code>: Its purpose is to construct the decomposition</p><p class="math-container">\[    K(x, y) \approx \sum_{\ell = 0}^L U_\ell(x) S_\ell V_\ell(y)\]</p><p>where <span>$U_\ell(x)$</span> and <span>$V_\ell(y)$</span> are called <span>$K$</span>&#39;s left and right singular functions respectively and <span>$S_\ell$</span> are its singular values. By construction, the singular functions form an orthonormal basis, i.e.</p><p class="math-container">\[    \int \dd{x} U_\ell(x) U_{\ell&#39;}(x) = \delta_{\ell\ell&#39;} = \int \dd{y} V_\ell(y) V_{\ell&#39;}(y).\]</p><p>and thus above equation is equivalent to a pair of eigenvalue equations</p><p class="math-container">\[\begin{aligned}
    S_\ell U_\ell(x) &amp;= \int \dd{y} K(x, y) V_\ell(y) \\
    S_\ell V_\ell(y) &amp;= \int \dd{x} K(x, y) U_\ell(x)
\end{aligned}\]</p><p>Here and in what follows, unless otherwise indicated, integrals are taken to be over the interval <span>$[-1,+1]$</span> (because we rescaled to <span>$x$</span> and <span>$y$</span> variables).</p><ol><li><p>The function first calls the <code>choose_accuracy</code> helper and thereby sets the appropriate working precision. Because we did not specify a working accuracy <span>$\varepsilon^2$</span>, it chooses machine precision <code>eps(Float64)</code>, i.e. <span>$\varepsilon \approx 2.2 \times 10^{-16}$</span> and working type <code>Float64x2</code> - a 128 bits floating point type provided by the MultiFloats.jl package - because in computing the SVD we incur a precision loss of about half our input bits. This leaves us with full double accuracy results only if we use quad precision during the computation.</p></li><li><p>Then - by calling out to the <code>CentrosymmSVE</code> constructor - a support grid <span>$\{x_i\} \times \{y_j\}$</span> for the kernel to be evaluated later on is built. Along with these support points, weights <span>$\{w_i\}$</span> and <span>$\{z_j\}$</span> are computed. These points and weights consist of repeated scaled Gauss integration rules, such that</p><p class="math-container">\[    \int \dd{x} f(x) \approx \sum_i f(x_i) w_i
    \quad\text{and}\quad
    \int \dd{y} g(y) \approx \sum_j g(y_j) z_j.\]</p><p>To get an idea regarding the distribution of these sampling points, refer to Fig. 2.2, which shows <span>$\{x_i\} \times \{y_j\}$</span> for <span>$\Lambda = 80$</span>: <img src="../assets/img/sve_grid.png" alt="Sampling point distribution resulting from a Cartesian product of Gauss integration rules."/></p><h4>Note:</h4><p>The points do not cover <span>$[-1, 1] \times [-1, 1]$</span> but only <span>$[0, 1] \times [0, 1]$</span>. This is actually a special case as we exploit the kernel&#39;s centrosymmetry, i.e. <span>$K(x, y) = K(-x, -y)$</span>. It is straightforward to show that the left/right singular vectors then can be chosen as either odd or even functions.</p><p>Consequentially, we actually sample from a reduced kernel <span>$K^\mathrm{red}_\pm$</span> on <span>$[0, 1] \times [0, 1]$</span> that is given as either</p><p class="math-container">\[    K^\mathrm{red}_\pm(x, y) = K(x, y) \pm K(x, -y),\]</p><p>gaining a 4-fold speedup (because we take only a quarter of the domain) in constructing the SVE. The full singular functions can be reconstructed by (anti-)symmetrically continuing them to the negative axis. <img src="../assets/img/kernel_red.png" alt="Reduced kernels, as a function of x and y, parameterizing imaginary time and real frequency, respectively. Compare their [0,1] × [0,1] subregions with the sampling point distribution plot above."/></p><p>Using the integration rules allows us to approximate</p><p class="math-container">\[\begin{aligned}
    S_\ell U_\ell(x_i) &amp;\approx \sum_j K(x_i, y_j) V_\ell(y_j) z_j &amp;&amp;\forall i \\
    S_\ell V_\ell(y_j) &amp;\approx \sum_i K(x_i, y_j) U_\ell(x_i) w_i &amp;&amp;\forall j
\end{aligned}\]</p><p>which we now multiply by <span>$\sqrt{w_i}$</span> and <span>$\sqrt{z_j}$</span> respectively to normalize our basis functions, yielding</p><p class="math-container">\[\begin{aligned}
    S_\ell \sqrt{w_i} U_\ell(x_i) &amp;\approx \sum_j \sqrt{w_i} K(x_i, y_j) \sqrt{z_j} \sqrt{z_j} V_\ell(y_j) \\
    S_\ell \sqrt{z_j} V_\ell(y_j) &amp;\approx \sum_i \sqrt{w_i} K(x_i, y_j) \sqrt{z_j} \sqrt{w_i} U_\ell(x_i)
\end{aligned}\]</p><p>If we now define vectors <span>$\vec u_\ell$</span>, <span>$\vec v_\ell$</span> and a matrix <span>$K$</span> with entries <span>$u_{\ell, i} \equiv \sqrt{w_i} U_\ell(x_i)$</span>, <span>$v_{\ell, j} \equiv \sqrt{z_j} V_\ell(y_j)$</span> and <span>$K_{ij} \equiv \sqrt{w_i} K(x_i, y_j) \sqrt{z_j}$</span>, we obtain</p><p class="math-container">\[\begin{aligned}
    S_\ell u_{\ell, i} &amp;\approx \sum_j K_{ij} v_{\ell, j} \\
    S_\ell v_{\ell, j} &amp;\approx \sum_i K_{ij} u_{\ell, i}
\end{aligned}\]</p><p>or</p><p class="math-container">\[\begin{aligned}
    S_\ell \vec u_\ell &amp;\approx K^{\phantom{\mathrm{T}}} \vec v_\ell \\
    S_\ell \vec v_\ell &amp;\approx K^\mathrm{T} \vec u_\ell.
\end{aligned}\]</p><p>Together with the property <span>$\vec u_\ell^\mathrm{T} \vec u_{\ell&#39;} \approx \delta_{\ell\ell&#39;} \approx \vec v_\ell^\mathrm{T} \vec v_{\ell&#39;}$</span> we have successfully translated the original SVE problem into an SVD, because</p><p class="math-container">\[    K = \sum_\ell S_\ell \vec u_\ell \vec v_\ell^\mathrm{T}.\]</p></li><li><p>The next step is calling the <code>matrices</code> function which computes the matrix <span>$K$</span> derived in the previous step.</p><div class="admonition is-info" id="Note-588e4c78b730fa06"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-588e4c78b730fa06" title="Permalink"></a></header><div class="admonition-body"><p>The function is named in the plural because in the centrosymmetric case it actually returns two matrices <span>$K_+$</span> and <span>$K_-$</span>, one for the even and one for the odd kernel. The SVDs of these matrices are later concatenated, so for simplicity, we will refer to <span>$K$</span> from here on out.</p></div></div><div class="admonition is-info" id="Info-8fae84afd28aae2c"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-8fae84afd28aae2c" title="Permalink"></a></header><div class="admonition-body"><p>Special care is taken here to avoid FP-arithmetic cancellation around <span>$x = -1$</span> and <span>$x = +1$</span>.</p></div></div><p><img src="../assets/img/kernel_red_matrices.png" alt="Kernel matrices, rotated 90 degrees counterclockwise to make the connection with the (subregion [0,1] × [0,1] of the) previous figure more obvious. Thus we can see how the choice of sampling points has magnified and brought to the matrices&#39; centers the regions of interest. Furthermore, elements with absolute values smaller than 10\\% of the maximum have been omitted to emphasize the structure; this should however not be taken to mean that there is any sparsity to speak of we could exploit in the next step."/></p></li><li><p>Take the truncated singular value decomposition (trSVD) of <span>$K$</span>, or rather, of <span>$K_+$</span> and <span>$K_-$</span>. We use here a custom trSVD routine written by Markus Wallerberger which combines a homemade rank-revealing QR decomposition with <code>GenericLinearAlgebra.svd!</code>. This is necessary because there is currently no trSVD for quad precision types available.</p></li><li><p>Via the function <code>truncate</code>, we throw away superfluous terms in our expansion. More specifically, we choose the basis size <span>$L$</span> such that <span>$S_\ell / S_0 &gt; \varepsilon$</span> for all <span>$\ell \leq L$</span>. Here <span>$\varepsilon$</span> is our selected precision, in our case it&#39;s equal to the double precision machine epsilon, <span>$2^{-52} \approx 2.22 \times 10^{-16}$</span>.</p></li><li><p>Finally, we need a postprocessing step implemented in <code>postprocess</code> which performs some technical manipulation to turn the SVD result into the SVE we actually want. The functions are represented as piecewise Legendre polynomials, which model a function on the interval <span>$[x_\mathrm{min}, x_\mathrm{max}]$</span> as a set of segments on the intervals <span>$[a_i, a_{i+1}]$</span>, where on each interval the function is expanded in scaled Legendre polynomials. The interval endpoints are chosen such that they reflect the approximate position of roots of a high-order singular function in <span>$x$</span>.</p></li></ol><h3 id="Finishing-touches"><a class="docs-heading-anchor" href="#Finishing-touches">Finishing touches</a><a id="Finishing-touches-1"></a><a class="docs-heading-anchor-permalink" href="#Finishing-touches" title="Permalink"></a></h3><p>The difficult part of constructing the <code>FiniteTempBasis</code> is now over. Next we truncate the left and right singular functions by discarding <span>$U_\ell$</span> and <span>$V_\ell$</span> with indices <span>$\ell &gt; L$</span> to match the <span>$S_\ell$</span>. The functions are now scaled to imaginary-time and frequency according to</p><p class="math-container">\[    \tau = \beta/2 (x + 1) \qand \omega = \omega_\mathrm{max} y.\]</p><p>This means the singular values need to be multiplied by <span>$\sqrt{(\beta/2)\omega_\mathrm{max}}$</span>, because <span>$K(x,y) \sqrt{\dd x\dd y} = K(\tau,\omega) \sqrt{\dd\tau\dd\omega}$</span>. We also add to our basis <span>$\hat{U}_\ell(\mathrm{i}\omega)$</span>, the Fourier transforms of the left singular functions, defined on the fermionic Matsubara frequencies <span>$\mathrm{i}\omega = \mathrm{i}(2n+1)\beta/\pi$</span> (with integer <span>$n$</span>). This is particularly simple, because the Legendre polynomials&#39; Fourier transforms are known analytically and given by spherical Bessel functions, for which we can rely on <code>Bessels.jl</code> [<a href="#Helton2022">6</a>].</p><p>We can now take a look at our basis functions to get a feel for them:</p><p><img src="../assets/img/u_basis.pdf" alt="First 6 left singular basis functions on the imaginary-time axis."/></p><p><img src="../assets/img/v_basis.pdf" alt="First 6 right singular basis functions on the frequency axis."/></p><p>Looking back at the image of the kernel <span>$K(x,y)$</span> we can imagine how it is reconstructed by multiplying and summing (including a factor <span>$S_\ell$</span>) <span>$U_\ell(\tau)$</span> and <span>$V_\ell(\omega)$</span>. An important property of the left singular functions is interlacing, i.e. <span>$U_\ell$</span> interlaces <span>$U_{\ell+1}$</span>. A function <span>$g$</span> with roots <span>$\alpha_{n-1} \leq \ldots \leq \alpha_1$</span> interlaces a function <span>$f$</span> with roots <span>$\beta_n \leq \ldots \leq \beta_1$</span> if</p><p class="math-container">\[    \beta_n \leq \alpha_{n-1} \leq \beta_{n-1} \leq \ldots \leq \beta_1.\]</p><p>We will use this property for constructing our sparse sampling set.</p><p><img src="../assets/img/uhat_basis.pdf" alt="First 8 Fourier transformed basis functions on the Matsubara frequency axis."/></p><p>As for the Matsubara basis functions, we plot only the non-zero components, i.e. <span>$\mathrm{Im}\;\hat U_\ell\,(\mathrm{i}\omega)$</span> with odd <span>$\ell$</span> and  <span>$\mathrm{Re}\;\hat U_\ell\,(\mathrm{i}\omega)$</span> with even <span>$\ell$</span>.</p><h2 id="Constructing-the-samplers"><a class="docs-heading-anchor" href="#Constructing-the-samplers">Constructing the samplers</a><a id="Constructing-the-samplers-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-the-samplers" title="Permalink"></a></h2><p>With our basis complete, we construct sparse sampling objects for fermionic propagators on the imaginary-time axis and on the Matsubara frequency axis.</p><pre><code class="language-julia-repl hljs">julia&gt; sτ = TauSampling(basis);

julia&gt; show(sampling_points(sτ))
[0.018885255323127792, 0.10059312563754808, 0.25218900406693556, 0.4822117319309194, 0.8042299148252774, 1.2376463941125326, 1.8067997157763205, 2.535059399842931, 3.4296355795122793, 4.45886851573216, 5.541131484267839, 6.570364420487721, 7.464940600157068, 8.19320028422368, 8.762353605887466, 9.195770085174722, 9.51778826806908, 9.747810995933065, 9.899406874362452, 9.981114744676873]

julia&gt; siω = MatsubaraSampling(basis; positive_only=true);

julia&gt; show(sampling_points(siω))
FermionicFreq[FermionicFreq(1), FermionicFreq(3), FermionicFreq(5), FermionicFreq(7), FermionicFreq(9), FermionicFreq(11), FermionicFreq(17), FermionicFreq(27), FermionicFreq(49), FermionicFreq(153)]</code></pre><p>Both functions first determine a suitable set of sampling points on their respective axis. In the case of <code>TauSampling</code>, the sampling points <span>$\{\tau_i\}$</span> are chosen as the extrema of the highest-order basis function in imaginary-time; this works because <span>$U_\ell$</span> has exactly <span>$\ell$</span> roots. This turns out to be close to optimal with respect to conditioning for this size (within a few percent). Similarly, <code>MatsubaraSampling</code> chooses sampling points <span>$\{\mathrm{i}\omega_n\}$</span> as the (discrete) extrema of the highest-order basis function in Matsubara. By setting <code>positive_only=true</code>, one assumes that functions to be fitted are symmetric in Matsubara frequency, i.e.</p><p class="math-container">\[    \hat G(\mathrm{i}\omega) = \qty(\hat G(-\mathrm{i}\omega))^*.\]</p><p>In this case, sparse sampling is performed over non-negative frequencies only, cutting away half of the necessary sampling space, so we get only 10 sampling points instead of the 20 in the imaginary-time case.</p><p>Then, both compute design matrices by <span>$E^\tau_{i\ell} = u_\ell(\tau_i)$</span> and <span>$E^\omega_{n\ell} = \hat{u}_\ell(i\omega_n)$</span> as well as their SVDs. We are now able to get the IR basis coefficients of a function that is known on the imaginary-time sampling points by solving the fitting problem</p><p class="math-container">\[    G_\ell = \mathrm{arg\,min}_{G_\ell} \sum_{\{\tau_i\}} \norm{G(\tau_i) - \sum_\ell E^\tau_{i\ell} G_\ell}^2,\]</p><p>which can be done efficiently once the SVD is known. The same can be done on the Matsubara axis</p><p class="math-container">\[    G_\ell = \mathrm{arg\,min}_{G_\ell} \sum_{\{\mathrm{i}\omega_n\}} \norm{\hat{G}(\mathrm{i}\omega_n) - \sum_\ell E^\omega_{n\ell} G_\ell}^2\]</p><p>and taken together we now have a way of moving efficiently between both. In solving these problems, we need to take their conditioning into consideration; in the case of the Matsubara axis, the problem is somewhat worse conditioned than on the imaginary-time axis due to its discrete nature. We augment it therefore with 4 additional sampling frequencies.</p><p><img src="../assets/img/condscaling.pdf" alt="Scaling behavior of the fitting problem conditioning."/></p><h2 id="Initializing-the-iteration"><a class="docs-heading-anchor" href="#Initializing-the-iteration">Initializing the iteration</a><a id="Initializing-the-iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Initializing-the-iteration" title="Permalink"></a></h2><p>Because the non-interacting density of states is given <span>$\rho_0(\omega) = \frac{2}{\pi}\sqrt{1 - \omega^2}$</span>, we can easily get the IR basis coefficients for the non-interacting propagator</p><p class="math-container">\[    {G_0}_\ell = -S_\ell {\rho_0}_\ell = -S_\ell \int \dd{\omega} V_\ell(\omega) \rho_0(\omega)\]</p><p>by utilizing the <code>overlap</code> function, which implements integration.</p><pre><code class="language-julia-repl hljs">julia&gt; U = 1.2
1.2

julia&gt; ρ₀(ω) = 2/π * √(1 - clamp(ω, -1, +1)^2)
ρ₀ (generic function with 1 method)

julia&gt; ρ₀l = overlap.(basis.v, ρ₀)
20-element Vector{Float64}:
  0.601244316541724
  1.3444106938820255e-17
 -0.3114509472896204
  ⋮
 -4.553649124439119e-18
 -0.04700635138837371
  1.734723475976807e-18

julia&gt; G₀l = -basis.s .* ρ₀l
20-element Vector{Float64}:
 -0.8663768456323275
 -1.6339906341599403e-17
  0.23834289781690587
  ⋮
  7.045824663886568e-23
  2.816974873845819e-7
 -3.924512839631511e-24</code></pre><p>The coefficients of the full Green&#39;s function are then initialized with those of the non-interacting one. Also, we will need the non-interacting propagator in Matsubara for the Dyson equation, so we <code>evaluate</code> with the <code>MatsubaraSampling</code> object created before.</p><pre><code class="language-julia-repl hljs">julia&gt; Gl = copy(G₀l)
20-element Vector{Float64}:
 -0.8663768456323275
 -1.6339906341599403e-17
  ⋮
  2.816974873845819e-7
 -3.924512839631511e-24

julia&gt; Σl = zero(Gl)
20-element Vector{ComplexF64}:
 0.0 + 0.0im
 0.0 + 0.0im
     ⋮
 0.0 + 0.0im
 0.0 + 0.0im

julia&gt; Gl_prev = zero(Gl)
20-element Vector{Float64}:
 0.0
 0.0
 ⋮
 0.0
 0.0

julia&gt; G₀iω = evaluate(siω, G₀l)
10-element Vector{ComplexF64}:
 1.0546844383198476e-16 - 1.468055523701327im
 1.6747120525708993e-16 - 0.8633270688082162im
                        ⋮
  1.627612150170272e-17 - 0.06489281188294724im
  6.134766817544449e-19 - 0.020802317001514643im</code></pre><h2 id="Self-consistency-loop"><a class="docs-heading-anchor" href="#Self-consistency-loop">Self-consistency loop</a><a id="Self-consistency-loop-1"></a><a class="docs-heading-anchor-permalink" href="#Self-consistency-loop" title="Permalink"></a></h2><p>We are now ready to tackle the coupled equations from the start, and will restate them here for the reader&#39;s convenience:</p><p class="math-container">\[    \Sigma(\tau) = U^2 \pqty{G(\tau)}^3\]</p><p>and the Dyson equation</p><p class="math-container">\[    \hat G(\mathrm{i}\omega) = \pqty{\pqty{\hat G_0(\mathrm{i}\omega)}^{-1} - \hat\Sigma(\mathrm{i}\omega)}^{-1}.\]</p><p>The first one is diagonal in <span>$\tau$</span> and the second is diagonal in <span>$\mathrm{i}\omega$</span>, so we employ the IR basis to efficiently convert between the two bases. Starting with our approximation to <span>$G_\ell$</span> we evaluate in the <span>$\tau$</span>-basis to get <span>$G(\tau)$</span>, from which we can compute the self-energy on the sampling points <span>$\Sigma(\tau)$</span> according to the first equation. This can now be fitted to the <span>$\tau$</span>-basis to get <span>$\Sigma_\ell$</span>, and from there <span>$\hat\Sigma(\mathrm{i}\omega)$</span> via evaluation in the <span>$\mathrm{i}\omega$</span>-basis. Now the Dyson equation is used to get <span>$\hat G(\mathrm{i}\omega)$</span> on the sampling frequencies, which is then fitted to the <span>$\mathrm{i}\omega$</span>-basis yielding <span>$G_\ell$</span> and completing the loop. This is now performed until convergence.</p><pre><code class="language-julia-repl hljs">julia&gt; while !isapprox(Gl, Gl_prev, rtol=ε)
           Gl_prev = copy(Gl)
           Gτ = evaluate(sτ, Gl)
           Στ = @. U^2 * Gτ^3
           Σl = fit(sτ, Στ)
           Σiω = evaluate(siω, Σl)
           Giω = @. (G₀iω^-1 - Σiω)^-1
           Gl = fit(siω, Giω)
       end</code></pre><p>This is what one iteration looks like spelled out in equations:</p><p class="math-container">\[\begin{aligned}
    G^\mathrm{prev}_\ell &amp;= G_\ell \\
    G(\tau_i) &amp;= \sum_\ell U_\ell(\tau_i) G_\ell \\
    \Sigma(\tau_i) &amp;= U^2 \pqty{G(\tau_i)}^3 \\
    \Sigma_\ell &amp;= \mathrm{arg\,min}_{\Sigma_\ell} \sum_{\{\tau_i\}} \norm{\Sigma(\tau_i) - \sum_\ell U_\ell(\tau_i) \Sigma_\ell}^2 \\
    \hat\Sigma(\mathrm{i}\omega_n) &amp;= \sum_\ell \hat U_\ell(\mathrm{i}\omega_n) \Sigma_\ell \\
    \hat G(\mathrm{i}\omega_n) &amp;= \pqty{\pqty{\hat G_0(\mathrm{i}\omega_n)}^{-1} - \hat\Sigma(\mathrm{i}\omega_n)}^{-1} \\
    G_\ell &amp;= \mathrm{arg\,min}_{G_\ell} \sum_{\{\mathrm{i}\omega_n\}} \norm{\hat G(\mathrm{i}\omega_n) - \sum_\ell \hat U_\ell(\mathrm{i}\omega_n) G_\ell}^2
\end{aligned}\]</p><p>We consider the iteration converged when the difference between subsequent iterations does not exceed the basis accuracy, i.e. when</p><p class="math-container">\[    \norm{G_\ell - G^\mathrm{prev}_\ell} \leq \varepsilon \max\Bqty{\norm{G_\ell}, \norm{G^\mathrm{prev}_\ell}},\]</p><p>where the norm is <span>$\norm{G_\ell}^2 = \sum_{\ell=1}^L G_\ell^2$</span>.</p><p>The entire script, as presented in <a href="#optimized-script">Appendix: Optimized script</a>, takes around 60ms to run on a laptop CPU from 2019 (Intel Core i7-9750H) and allocates roughly 19MB in the process.</p><h2 id="Visualizing-the-solution"><a class="docs-heading-anchor" href="#Visualizing-the-solution">Visualizing the solution</a><a id="Visualizing-the-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Visualizing-the-solution" title="Permalink"></a></h2><p>To plot our solution for the self-energy, we create a <code>MatsubaraSampling</code> object on a dense box of sampling frequencies. In this case, we only need it for expanding, i.e. multiplying a vector, hence there is no need for constructing the SVD, so we pass <code>factorize=false</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; box = FermionicFreq.(1:2:79)
40-element Vector{FermionicFreq}:
  π/β
  3π/β
                 ⋮
 77π/β
 79π/β

julia&gt; siω_box = MatsubaraSampling(basis; sampling_points=box, factorize=false);

julia&gt; Σiω_box = evaluate(siω_box, Σl)
40-element Vector{ComplexF64}:
 -6.067770915322836e-17 - 0.09325923974719101im
 2.0279596075077236e-17 - 0.1225916020773678im
                        ⋮
 -6.624594477591435e-17 - 0.014786512975659354im
  -7.08391512971528e-17 - 0.01441676347590391im</code></pre><p>We are now in a position to visualize the results of our calculation in Fig 2.9:</p><ul><li>In the main plot, the imaginary part of the self-energy in Matsubara alongside the sampling points on which it was computed. This illustrates very nicely one of the main advantages of our method: During the entire course of the iteration we only ever need to store and calculate the values of all functions on the sparse set of sampling points and are still able to expand the result on a dense frequency set in the end.</li><li>In the inset, the IR basis coefficients of the self-energy and of the propagator are shown, along with the basis singular values. We only plot the non-vanishing basis coefficients, which are those at odd values of <span>$\ell$</span> because the real parts of <span>$\hat G(\mathrm{i}\omega)$</span> and <span>$\hat \Sigma(\mathrm{i}\omega)$</span> are almost zero. The singular values <span>$S_\ell/S_1$</span> are the bound for <span>$\abs{G_l / G_1}$</span> and <span>$\abs{\Sigma_\ell / \Sigma_1}$</span>.</li></ul><p><img src="../assets/img/result.pdf" alt="Self-energy calculated in the self-consistency iteration. The inset shows the IR basis coefficients corresponding to the self-energy and the propagator."/></p><h1 id="Summary-and-outlook"><a class="docs-heading-anchor" href="#Summary-and-outlook">Summary and outlook</a><a id="Summary-and-outlook-1"></a><a class="docs-heading-anchor-permalink" href="#Summary-and-outlook" title="Permalink"></a></h1><p>We introduced <code>SparseIR.jl</code>, a full featured implementation of the intermediate representation in the Julia programming language. By means of a simple example, we explained in detail how to use it and the way it works internally. In this example, we solved an Anderson impurity model with elliptical density of states to second order perturbation theory in the interaction via a self-consistent loop. We successfully obtained the self-energy (accurate to second order) with minimal computational effort.</p><p>Regarding further work, perhaps the single most obvious direction is the extension to multi-particle quantities; And indeed, Refs. [<a href="#Shinaoka2018">7</a>, <a href="#Wallerberger2021">8</a>] did exactly this, with Markus Wallerberger writing the as of yet unpublished Julia library <code>OvercompleteIR.jl</code> which builds upon <code>SparseIR.jl</code>. So, as a transitive dependency, the library of the present thesis has already found applications in solving the parquet equations for the Hubbard model and for the Anderson impurity model [<a href="#Michalek2024">9</a>].</p><h1 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h1><div class="citation canonical"><dl><dt>[1]</dt><dd><div id="Shinaoka2017">H. Shinaoka, J. Otsuki, M. Ohzeki and K. Yoshimi. <em>Compressing Green&#39;s function using intermediate representation between imaginary-time and real-frequency domains</em>. <a href="https://doi.org/10.1103/PhysRevB.96.035147">Physical Review B <strong>96</strong>, 35147</a> (2017).</div></dd><dt>[2]</dt><dd><div id="Li2020">J. Li, M. Wallerberger, N. Chikano, C.-N. Yeh, E. Gull and H. Shinaoka. <em>Sparse sampling approach to efficient ab initio calculations at finite temperature</em>. <a href="https://doi.org/10.1103/physrevb.101.035144">Physical Review B <strong>101</strong>, 035144</a> (2020).</div></dd><dt>[3]</dt><dd><div id="Shinaoka2022">H. Shinaoka, N. Chikano, E. Gull, J. Li, T. Nomoto, J. Otsuki, M. Wallerberger, T. Wang and K. Yoshimi. <a href="https://scipost.org/10.21468/SciPostPhysLectNotes.63"><em>Efficient ab initio many-body calculations based on sparse modeling of Matsubara Green&#39;s function</em></a>. <a href="https://doi.org/10.21468/SciPostPhysLectNotes.63">SciPost Phys. Lect. Notes, 63</a> (2022).</div></dd><dt>[4]</dt><dd><div id="Wallerberger2023">M. Wallerberger, S. Badr, S. Hoshino, S. Huber, F. Kakizawa, T. Koretsune, Y. Nagai, K. Nogaki, T. Nomoto, H. Mori, J. Otsuki, S. Ozaki, T. Plaikner, R. Sakurai, C. Vogel, N. Witt, K. Yoshimi and H. Shinaoka, <em>sparse-ir: Optimal compression and sparse sampling of many-body propagators</em>. <a href="https://doi.org/10.1016/j.softx.2022.101266">SoftwareX <strong>21</strong>, 101266</a> (2023-02).</div></dd><dt>[5]</dt><dd><div id="Hansen2010">P. C. Hansen. <a href="https://doi.org/10.1137/1.9780898718836"><em>Discrete Inverse Problems: Insights and Algorithms</em></a> (SIAM, 2010).</div></dd><dt>[6]</dt><dd><div id="Helton2022">M. Helton and O. Smith. <a href="https://github.com/JuliaMath/Bessels.jl"><em>Bessels.jl</em></a> (2022).</div></dd><dt>[7]</dt><dd><div id="Shinaoka2018">H. Shinaoka, J. Otsuki, K. Haule, M. Wallerberger, E. Gull, K. Yoshimi and M. Ohzeki. <em>Overcomplete compact representation of two-particle Green&#39;s functions</em>. <a href="https://doi.org/10.1103/PhysRevB.97.205111">Physical Review B <strong>97</strong>, 205111</a> (2018-05).</div></dd><dt>[8]</dt><dd><div id="Wallerberger2021">M. Wallerberger, H. Shinaoka and A. Kauch. <em>Solving the Bethe-Salpeter equation with exponential convergence</em>. <a href="https://doi.org/10.1103/PhysRevResearch.3.033168">Physical Review Research <strong>3</strong>, 033168</a> (2021-08).</div></dd><dt>[9]</dt><dd><div id="Michalek2024">M. Michalek. <em>Solving the Anderson impurity model with intermediate representation of the parquet equations</em> (2024). Bachelor&#39;s thesis, TU Wien.</div></dd></dl></div><h1 id="optimized-script"><a class="docs-heading-anchor" href="#optimized-script">Appendix: Optimized script</a><a id="optimized-script-1"></a><a class="docs-heading-anchor-permalink" href="#optimized-script" title="Permalink"></a></h1><p>With minimal modifications we can transform our code to be more optimized for performance:</p><ul><li>Put script in a function. This is because globals are type instable in Julia.</li><li>Add <code>::Vector{Float64}</code> annotation to ensure type inferrability of <code>ρ₀l</code>.</li><li><code>Gl</code> in the loop will be a <code>Vector{ComplexF64}</code> in the loop, so make it <code>complex</code> right away for type stability.</li><li>Preallocate and reuse arrays to remove allocations in the loop, minimizing total allocations and time spent garbage collecting. Here we benefit from <code>SparseIR.jl</code> providing in-place variants <code>fit!</code> and <code>evaluate!</code>.</li></ul><pre><code class="language-julia hljs">using SparseIR

function main(; β=10.0, ωmax=8.0, ε=1e-6)
    # Construct the IR basis and sparse sampling for fermionic propagators
    basis = FiniteTempBasis{Fermionic}(β, ωmax, ε)
    sτ = TauSampling(basis)
    siω = MatsubaraSampling(basis; positive_only=true)

    # Solve the single impurity Anderson model coupled to a bath with a
    # semicircular density of states with unit half bandwidth.
    U = 1.2
    ρ₀(ω) = 2 / π * √(1 - clamp(ω, -1, +1)^2)

    # Compute the IR basis coefficients for the non-interacting propagator
    ρ₀l = overlap.(basis.v, ρ₀)::Vector{Float64}
    G₀l = -basis.s .* ρ₀l

    # Self-consistency loop: alternate between second-order expression for the
    # self-energy and the Dyson equation until convergence.
    Gl = complex(G₀l)
    G₀iω = evaluate(siω, G₀l)

    # Preallocate arrays for the self-energy and the Green&#39;s function
    Σl = similar(Gl)
    Στ = similar(Gl, ComplexF64, length(sampling_points(sτ)))
    Σiω = similar(G₀iω)
    Gτ = similar(Στ)
    Giω = similar(G₀iω)

    Gl_prev = zero(Gl)
    while !isapprox(Gl, Gl_prev, rtol=ε)
        Gl_prev .= Gl
        evaluate!(Gτ, sτ, Gl)
        @. Στ = U^2 * Gτ^3
        fit!(Σl, sτ, Στ)
        evaluate!(Σiω, siω, Σl)
        @. Giω = (G₀iω^-1 - Σiω)^-1
        fit!(Gl, siω, Giω)
    end
    return basis, Σl
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../public/">Public »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 24 December 2025 08:59">Wednesday 24 December 2025</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
