<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Guide · SparseIR.jl</title><meta name="title" content="Guide · SparseIR.jl"/><meta property="og:title" content="Guide · SparseIR.jl"/><meta property="twitter:title" content="Guide · SparseIR.jl"/><meta name="description" content="Documentation for SparseIR.jl."/><meta property="og:description" content="Documentation for SparseIR.jl."/><meta property="twitter:description" content="Documentation for SparseIR.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SparseIR.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Guide</a><ul class="internal"><li><a class="tocitem" href="#Problem-statement"><span>Problem statement</span></a></li><li><a class="tocitem" href="#Treatment"><span>Treatment</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../public/">Public</a></li><li><a class="tocitem" href="../private/">Private</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Guide</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SpM-lab/SparseIR.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SpM-lab/SparseIR.jl/blob/main/docs/src/guide.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="guide"><a class="docs-heading-anchor" href="#guide">Example usage and detailed explanation</a><a id="guide-1"></a><a class="docs-heading-anchor-permalink" href="#guide" title="Permalink"></a></h1><p>We will explain the inner workings of <code>SparseIR.jl</code> by means of an example use case, adapted from the <code>sparse-ir</code> paper [<a href="#Wallerberger2023">1</a>].</p><h2 id="Problem-statement"><a class="docs-heading-anchor" href="#Problem-statement">Problem statement</a><a id="Problem-statement-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-statement" title="Permalink"></a></h2><blockquote><p>Let us perform self-consistent second-order perturbation theory for the single impurity Anderson model at finite temperature. Its Hamiltonian is given by</p><p class="math-container">\[    H = U c^\dagger_\uparrow c^\dagger_\downarrow c_\downarrow c_\uparrow + \sum_{p\sigma} \big(V_{p\sigma}  f_{p\sigma}^\dagger c_\sigma + V_{p\sigma}^* c_\sigma^\dagger c_\sigma^\dagger\big) + \sum_{p\sigma} \epsilon_{p} f_{p\sigma}^\dagger f_{p\sigma}\]</p><p>where <span>$U$</span> is the electron interaction strength, <span>$c_\sigma$</span> annihilates an electron on the impurity, <span>$f_{p\sigma}$</span> annihilates an electron in the bath, <span>$\dagger$</span> denotes the Hermitian conjugate, <span>$p\in\mathbb R$</span> is bath momentum, and <span>$\sigma\in\{\uparrow, \downarrow\}$</span> is spin. The hybridization strength <span>$V_{p\sigma}$</span> and bath energies <span>$\epsilon_p$</span> are chosen such that the non-interacting density of states is semi-elliptic with a half-bandwidth of one, <span>$\rho_0(\omega) = \frac2\pi\sqrt{1-\omega^2}$</span>, <span>$U=1.2$</span>, <span>$\beta=10$</span>, and the system is assumed to be half-filled.</p></blockquote><h2 id="Treatment"><a class="docs-heading-anchor" href="#Treatment">Treatment</a><a id="Treatment-1"></a><a class="docs-heading-anchor-permalink" href="#Treatment" title="Permalink"></a></h2><h3 id="Outline"><a class="docs-heading-anchor" href="#Outline">Outline</a><a id="Outline-1"></a><a class="docs-heading-anchor-permalink" href="#Outline" title="Permalink"></a></h3><p>To provide an overview, we first give the full code used to solve the problem with <code>SparseIR.jl</code>.</p><pre><code class="language-julia hljs">using SparseIR

function main(ε = 1e-6)
    β = 10.0
    ωmax = 8.0

    # Construct the IR basis and sparse sampling for fermionic propagators
    basis = FiniteTempBasis{Fermionic}(β, ωmax, ε)
    sτ = TauSampling(basis)
    siω = MatsubaraSampling(basis; positive_only=true)
    
    # Solve the single impurity Anderson model coupled to a bath with a
    # semicircular density of states with unit half bandwidth.
    U = 1.2
    ρ₀(ω) = 2/π * √(1 - clamp(ω, -1, +1)^2)
    
    # Compute the IR basis coefficients for the non-interacting propagator
    ρ₀l = overlap.(basis.v, ρ₀)
    G₀l = -basis.s .* ρ₀l
    
    # Self-consistency loop: alternate between second-order expression for the
    # self-energy and the Dyson equation until convergence.
    Gl = copy(G₀l)
    Gl_prev = zero(Gl)
    G₀iω = evaluate(siω, G₀l)
    while !isapprox(Gl, Gl_prev, atol=ε)
        Gl_prev = copy(Gl)
        Gτ = evaluate(sτ, Gl)
        Στ = @. U^2 * Gτ^3
        Σl = fit(sτ, Στ)
        Σiω = evaluate(siω, Σl)
        Giω = @. (G₀iω^-1 - Σiω)^-1
        Gl = fit(siω, Giω)
    end
end</code></pre><p>The following is a detailed explanation of what happens here.</p><h3 id="Basis-construction"><a class="docs-heading-anchor" href="#Basis-construction">Basis construction</a><a id="Basis-construction-1"></a><a class="docs-heading-anchor-permalink" href="#Basis-construction" title="Permalink"></a></h3><p>We first import <code>SparseIR</code> and construct an appropriate basis (<span>$\omega_\mathrm{max} = 8$</span> should be more than enough for this example):</p><pre><code class="language-julia-repl hljs">julia&gt; using SparseIR

julia&gt; β = 10.0; ωmax = 8.0; ε = 1e-6;

julia&gt; basis = FiniteTempBasis{Fermionic}(β, ωmax, ε)
20-element FiniteTempBasis{Fermionic} with β = 10.0, ωmax = 8.0 and singular values:
 1.4409730317545617
 1.2153954454510802
 0.7652662478347486
 0.49740673945822533
 0.288562095623106
 0.1639819552743817
 0.08901271087151318
 0.046837974354297436
 0.023857653233506308
 0.01179373309602762
 0.005662400021411787
 0.0026427291749051072
 0.0011996720525663963
 0.0005299554043095754
 0.00022790287514550545
 9.544046906619884e-5
 3.8931895383167936e-5
 1.5472919567017398e-5
 5.992753725069063e-6
 2.2623276239584257e-6</code></pre><p>There is quite a lot happening behind the scenes in this first innocuous-looking statement, so we will break it down: Because we did not specify otherwise, the constructor chose the analytic continuation kernel for fermions, <code>LogisticKernel(80.0)</code>, defined by</p><p class="math-container">\[    K(x, y) = \frac{e^{-\Lambda y (x + 1) / 2}}{1 + e^{-\Lambda y}},\]</p><p>for us, where 80.0 is the value of the scale parameter <span>$\Lambda = \beta\omega_\mathrm{max}$</span>. This kernel is visualized below.</p><img src="../assets/img/kernel.png" alt="Logistic Kernel" width="70%" class="center"/><h4 id="Singular-value-expansion"><a class="docs-heading-anchor" href="#Singular-value-expansion">Singular value expansion</a><a id="Singular-value-expansion-1"></a><a class="docs-heading-anchor-permalink" href="#Singular-value-expansion" title="Permalink"></a></h4><p>Central is the <em>singular value expansion</em>&#39;s (SVE) computation, which is handled by the function <code>SVEResult</code>: Its purpose is to construct the decomposition</p><p class="math-container">\[    K(x, y) \approx \sum_{\ell = 0}^L U_\ell(x) S_\ell V_\ell(y)\]</p><p>where <span>$U_\ell(x)$</span> and <span>$V_\ell(y)$</span> are called <span>$K$</span>&#39;s left and right singular functions respectively and <span>$S_\ell$</span> are its singular values. By construction, the singular functions form an orthonormal basis, i.e.</p><p class="math-container">\[    \int \dd{x} U_\ell(x) U_{\ell&#39;}(x) = \delta_{\ell\ell&#39;} = \int \dd{y} V_\ell(y) V_{\ell&#39;}(y).\]</p><p>and thus</p><p class="math-container">\[\left.
\begin{aligned}
    S_\ell U_\ell(x) &amp;= \int \dd{y} K(x, y) V_\ell(y) \\
    S_\ell V_\ell(y) &amp;= \int \dd{x} K(x, y) U_\ell(x)
\end{aligned}
\right\}\]</p><p>Here and in what follows, unless otherwise indicated, integrals are taken to be over the interval <span>$[-1,1]$</span>.</p><ol><li><p>The function first calls the <code>choose_accuracy</code> helper and thereby sets the appropriate working precision. Because we did not specify a working accuracy <span>$\varepsilon$</span>, it chooses for us <span>$\varepsilon \approx 2.2 \times 10^{-16}$</span> and working type <code>Float64x2</code> - a 128 bits floating point type provided by the MultiFloats.jl package - because in computing the SVD we incur a precision loss of about half our input bits, leaving us with full double accuracy results only if we use quad precision during the computation.</p></li><li><p>Then - by calling out to the <code>CentrosymmSVE</code> constructor - a support grid <span>$\{x_i\} \times \{y_j\}$</span> the kernel will later be evaluated on is built. Along with these support points weights <span>$\{w_i\}$</span> and <span>$\{z_j\}$</span> are computed. These points and weights consist of repeated scaled Gauss integration rules, such that</p><p class="math-container">\[    \int \dd{x} f(x) \approx \sum_i f(x_i) w_i
    \quad\text{and}\quad
    \int \dd{y} g(y) \approx \sum_j g(y_j) z_j.\]</p><p>To get an idea regarding the distribution of these sampling points, refer to following figure, which shows <span>$\{x_i\} \times \{y_j\}$</span> for <span>$\Lambda = 80$</span>:</p><p><img src="../assets/img/sve_grid.png" alt="Sampling point distribution"/></p><h5>Note:</h5><p>The points do not cover <span>$[-1, 1] × [-1, 1]$</span> but only <span>$[0, 1] × [0, 1]$</span>. This is actually a special case as we exploit the kernel&#39;s centrosymmetry, i.e. <span>$K(x, y) = K(-x, -y)$</span>. It is straightforward to show that the left/right singular vectors then can be chosen as either odd or even functions.</p><p>Consequentially, they are singular functions of a reduced kernel <span>$K^\mathrm{red}_\pm$</span> on <span>$[0, 1] × [0, 1]$</span> that is given as either:</p><p class="math-container">\[    K^\mathrm{red}_\pm(x, y) = K(x, y) \pm K(x, -y)\]</p><p>It is these reduced kernels we will actually sample from, gaining a 4-fold speedup in constructing the SVE. <img src="../assets/img/kernel_red.png" alt="abc"/></p><p>Using the integration rules allows us to approximate</p><p class="math-container">\[\left.
\begin{aligned}
    S_\ell U_\ell(x_i) &amp;\approx \sum_j K(x_i, y_j) V_\ell(y_j) z_j &amp;&amp;\forall i \\
    S_\ell V_\ell(y_j) &amp;\approx \sum_i K(x_i, y_j) U_\ell(x_i) w_i &amp;&amp;\forall j
\end{aligned}
\right\}\]</p><p>which we now multiply by <span>$\sqrt{w_i}$</span> and <span>$\sqrt{z_j}$</span> respectively, yielding</p><p class="math-container">\[\left.
\begin{aligned}
    S_\ell \sqrt{w_i} U_\ell(x_i) &amp;\approx \sum_j \sqrt{w_i} K(x_i, y_j) \sqrt{z_j} \sqrt{z_j} V_\ell(y_j) \\
    S_\ell \sqrt{z_j} V_\ell(y_j) &amp;\approx \sum_i \sqrt{w_i} K(x_i, y_j) \sqrt{z_j} \sqrt{w_i} U_\ell(x_i)
\end{aligned}
\right\}\]</p><p>If we now define vectors <span>$\vec u_\ell$</span>, <span>$\vec v_\ell$</span> and a matrix <span>$K$</span> with entries <span>$u_{\ell, i} \equiv \sqrt{w_i} U_\ell(x_i)$</span>, <span>$v_{\ell, j} \equiv \sqrt{z_j} V_\ell(y_j)$</span> and <span>$K_{ij} \equiv \sqrt{w_i} K(x_i, y_j) \sqrt{z_j}$</span>, then</p><p class="math-container">\[\left.
\begin{aligned}
    S_\ell u_{\ell, i} &amp;\approx \sum_j K_{ij} v_{\ell, j} \\
    S_\ell v_{\ell, j} &amp;\approx \sum_i K_{ij} u_{\ell, i}
\end{aligned}
\right\}\]</p><p>or</p><p class="math-container">\[\left.
\begin{aligned}
    S_\ell \vec u_\ell &amp;\approx K^{\phantom{\mathrm{T}}} \vec v_\ell \\
    S_\ell \vec v_\ell &amp;\approx K^\mathrm{T} \vec u_\ell.
\end{aligned}
\right\}\]</p><p>Together with the property <span>$\vec u_\ell^\mathrm{T} \vec u_{\ell&#39;} \approx \delta_{\ell\ell&#39;} \approx \vec v_\ell^\mathrm{T} \vec v_{\ell&#39;}$</span> we have successfully translated the original SVE problem into an SVD, because</p><p class="math-container">\[    K = \sum_\ell S_\ell \vec u_\ell \vec v_\ell^\mathrm{T}.\]</p></li><li><p>The next step is calling the <code>matrices</code> function which computes the matrix <span>$K$</span> derived in the previous step.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The function is named in the plural because in the centrosymmetric case it actually returns two matrices <span>$K_+$</span> and <span>$K_-$</span>, one for the even and one for the odd kernel. The SVDs of these matrices are later concatenated, so for simplicity, we will refer to <span>$K$</span> from here on out.</p></div></div><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Special care is taken here to avoid FP-arithmetic cancellation around <span>$x = -1$</span> and <span>$x = +1$</span>.</p></div></div><p><img src="../assets/img/kernel_red_matrices.png" alt="Kernel matrices"/> Note that in the plot, the matrices are rotated 90 degrees to the left to make the connection with the (subregion <span>$[0, 1] \times [0, 1]$</span> of the) previous figure more obvious. Thus we can see how the choice of sampling points has magnified and brought to the matrices&#39; centers the regions of interest. Furthermore, elements with absolute values smaller than <span>$10\%$</span> of the maximum have been omitted to emphasize the structure; this should however not be taken to mean that there is any sparsity to speak of we could exploit in the next step.</p></li><li><p>Take the truncated singular value decomposition (TSVD) of <span>$K$</span>, or rather, of <span>$K_+$</span> and <span>$K_-$</span>. We use here a custom TSVD routine written by Markus Wallerberger which combines a homemade rank-revealing QR decomposition with <code>GenericLinearAlgebra.svd!</code>. This is necessary because there is currently no TSVD for arbitrary types available.</p></li><li><p>Via the function <code>truncate</code>, we throw away superfluous terms in our expansion. More specifically, we choose the basis size <span>$L$</span> such that <span>$S_\ell / S_0 &gt; \varepsilon$</span> for all <span>$\ell \leq L$</span>. Here <span>$\varepsilon$</span> is our selected precision, in our case it&#39;s equal to the double precision machine epsilon, <span>$2^{-52} \approx 2.22 \times 10^{-16}$</span>.</p></li><li><p>Finally, we need a postprocessing step implemented in <code>postprocess</code> which performs some technical manipulation to turn the SVD result into the SVE we actually want. The functions are represented as piecewise Legendre polynomials, which model a function on the interval <span>$[x_\mathrm{min}, x_\mathrm{max}]$</span> as a set of segments on the intervals <span>$[a_i, a_{i+1}]$</span>, where on each interval the function is expanded in scaled Legendre polynomials.</p></li></ol><h4 id="The-finishing-touches"><a class="docs-heading-anchor" href="#The-finishing-touches">The finishing touches</a><a id="The-finishing-touches-1"></a><a class="docs-heading-anchor-permalink" href="#The-finishing-touches" title="Permalink"></a></h4><p>The difficult part of constructing the <code>FiniteTempBasis</code> is now over. Next we truncate the left and right singular functions by discarding <span>$U_\ell$</span> and <span>$V_\ell$</span> with indices <span>$\ell &gt; L$</span> to match the <span>$S_\ell$</span>. The functions are now scaled to imaginary time and frequency according to</p><p class="math-container">\[    \tau = \beta/2 (x + 1) \qand \omega = \omega_\mathrm{max} y\]</p><p>and to match them, the singular values are multiplied by <span>$\sqrt{(\beta/2)\omega}$</span>. We also add to our basis <span>$\hat{U}_\ell(i\omega)$</span>, the Fourier transforms of the left singular functions, defined on the fermionic Matsubara frequencies <span>$i\omega = i(2n+1)\beta/\pi$</span> (with integer <span>$n$</span>). This is particularly simple, because the Legendre polynomials&#39; Fourier transforms are known analytically and given by spherical Bessel functions, for which we can rely on <code>Bessels.jl</code> [<a href="#Helton2022">2</a>].</p><h3 id="Constructing-the-samplers"><a class="docs-heading-anchor" href="#Constructing-the-samplers">Constructing the samplers</a><a id="Constructing-the-samplers-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-the-samplers" title="Permalink"></a></h3><p>With our basis complete, we construct sparse sampling objects for fermionic propagators on the imaginary time axis and on the Matsubara frequency axis.</p><pre><code class="language-julia-repl hljs">julia&gt; sτ = TauSampling(basis)
TauSampling64 with sampling points:
 0.018885255323127792
 0.10059312563754808
 0.25218900406693556
 0.4822117319309194
 0.8042299148252774
 1.2376463941125326
 1.8067997157763205
 2.535059399842931
 3.4296355795122793
 4.45886851573216
 5.541131484267839
 6.570364420487721
 7.464940600157068
 8.19320028422368
 8.762353605887466
 9.195770085174722
 9.51778826806908
 9.747810995933065
 9.899406874362452
 9.981114744676873

julia&gt; siω = MatsubaraSampling(basis; positive_only=true)
MatsubaraSampling{FermionicFreq, ComplexF64, SparseIR.SplitSVD{Float64}} with sampling points:
 FermionicFreq(1)
 FermionicFreq(3)
 FermionicFreq(5)
 FermionicFreq(7)
 FermionicFreq(9)
 FermionicFreq(11)
 FermionicFreq(17)
 FermionicFreq(27)
 FermionicFreq(49)
 FermionicFreq(153)</code></pre><p>Both functions first determine a suitable set of sampling points on their respective axis. In the case of <code>TauSampling</code>, the sampling points <span>$\{\tau_i\}$</span> are chosen as the extrema of the highest-order basis function in imaginary time. This turns out to be close to optimal with respect to conditioning for this size (within a few percent). Similarly, <code>MatsubaraSampling</code> chooses sampling points <span>$\{i\omega_n\}$</span> as the (discrete) extrema of the highest-order basis function in Matsubara. By setting <code>positive_only=true</code>, one assumes that functions to be fitted are symmetric in Matsubara frequency, i.e.:</p><p class="math-container">\[    \hat G(i\omega) = \qty(\hat G(-i\omega))^*\]</p><p>or equivalently, that they are purely real in imaginary time. In this case, sparse sampling is performed over non-negative frequencies only, cutting away half of the necessary sampling space, so we get only 10 sampling points instead of the 20 in the imaginary time case.</p><p>Then, both compute design matrices by <span>$E^\tau_{i\ell} = u_\ell(\tau_i)$</span> and <span>$E^\omega_{n\ell} = \hat{u}_\ell(i\omega_n)$</span> as well as their SVDs. We are now able to get the IR basis coefficients of a function that is known on the imaginary time sampling points by solving the fitting problem</p><p class="math-container">\[\DeclareMathOperator*{\argmin}{arg\,min}
    G_\ell = \argmin_{G_\ell} \sum_i \norm{G(\tau_i) - \sum_\ell E^\tau_{i\ell} G_\ell}^2,\]</p><p>which can be done efficiently once the SVD is known. The same can be done on the Matsubara axis</p><p class="math-container">\[    G_\ell = \argmin_{G_\ell} \sum_n \norm{\hat{G}(i\omega_n) - \sum_\ell E^\omega_{n\ell} G_\ell}^2\]</p><p>and taken together we now have a way of moving efficiently between both.</p><h3 id="Initializing-the-iteration"><a class="docs-heading-anchor" href="#Initializing-the-iteration">Initializing the iteration</a><a id="Initializing-the-iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Initializing-the-iteration" title="Permalink"></a></h3><p>Because the non-interacting density of states is given <span>$\rho_0(\omega) = \frac{2}{\pi}\sqrt{1 - \omega^2}$</span>, we can easily get the IR basis coefficients for the non-interacting propagater</p><p class="math-container">\[    {G_0}_\ell = -S_\ell {\rho_0}_\ell = -S_\ell \int \dd{\omega} V_\ell(\omega) \rho_0(\omega)\]</p><p>by utilizing the <code>overlap</code> function, which implements integration.</p><pre><code class="language-julia-repl hljs">julia&gt; U = 1.2
1.2

julia&gt; ρ₀(ω) = 2/π * √(1 - clamp(ω, -1, +1)^2)
ρ₀ (generic function with 1 method)

julia&gt; ρ₀l = overlap.(basis.v, ρ₀)
20-element Vector{Float64}:
  0.601244316541724
  1.3444106938820255e-17
 -0.3114509472896204
  ⋮
 -4.553649124439119e-18
 -0.04700635138837371
  1.734723475976807e-18

julia&gt; G₀l = -basis.s .* ρ₀l
20-element Vector{Float64}:
 -0.8663768456323275
 -1.6339906341599403e-17
  0.23834289781690587
  ⋮
  7.045824663886568e-23
  2.816974873845819e-7
 -3.924512839631511e-24</code></pre><p>The coefficients of the full Green&#39;s function are then initialized with those of the non-interacting one. Also, we will need the non-interacting propagator in Matsubara for the Dyson equation, so we <code>evaluate</code> with the <code>MatsubaraSampling</code> object created before.</p><pre><code class="language-julia-repl hljs">julia&gt; Gl = copy(G₀l)
20-element Vector{Float64}:
 -0.8663768456323275
 -1.6339906341599403e-17
  ⋮
  2.816974873845819e-7
 -3.924512839631511e-24

julia&gt; Gl_prev = zero(Gl)
20-element Vector{Float64}:
 0.0
 0.0
 ⋮
 0.0
 0.0

julia&gt; G₀iω = evaluate(siω, G₀l)
10-element Vector{ComplexF64}:
 1.0546844383198476e-16 - 1.468055523701327im
 1.6747120525708993e-16 - 0.8633270688082162im
                        ⋮
  1.627612150170272e-17 - 0.06489281188294724im
  6.134766817544449e-19 - 0.020802317001514643im</code></pre><h3 id="Self-consistency-loop"><a class="docs-heading-anchor" href="#Self-consistency-loop">Self-consistency loop</a><a id="Self-consistency-loop-1"></a><a class="docs-heading-anchor-permalink" href="#Self-consistency-loop" title="Permalink"></a></h3><p>If we take the second-order expression for the self-energy</p><p class="math-container">\[    \Sigma(\tau) = U^2 \pqty{G(\tau)}^3\]</p><p>and the Dyson equation</p><p class="math-container">\[    \hat G(i\omega) = \pqty{\pqty{\hat G_0(i\omega)}^{-1} - \Sigma(i\omega)}^{-1}\]</p><p>we have a system of two coupled equations. The first one is diagonal in <span>$\tau$</span> and the second is diagonal in <span>$i\omega$</span>, so we employ the IR basis to efficiently convert between the two bases. Starting with our approximation to <span>$G_\ell$</span> we evaluate in the <span>$\tau$</span>-basis to get <span>$G(\tau)$</span>, from which we can compute the self-energy on the sampling points <span>$\Sigma(\tau)$</span> according to the first equation. This can now be fitted to the <span>$\tau$</span>-basis to get <span>$\Sigma_\ell$</span>, and from there <span>$\hat\Sigma(i\omega)$</span> via evaluation in the <span>$i\omega$</span>-basis. Now the Dyson equation is used to get <span>$\hat G(i\omega)$</span> on the sampling frequencies, which is then fitted to the <span>$i\omega$</span>-basis yielding <span>$G_\ell$</span> and completing the loop. This is now performed until convergence.</p><pre><code class="language-julia-repl hljs">julia&gt; while !isapprox(Gl, Gl_prev, atol=ε)
           Gl_prev = copy(Gl)
           Gτ = evaluate(sτ, Gl)
           Στ = @. U^2 * Gτ^3
           Σl = fit(sτ, Στ)
           Σiω = evaluate(siω, Σl)
           Giω = @. (G₀iω^-1 - Σiω)^-1
           Gl = fit(siω, Giω)
       end</code></pre><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><div class="citation canonical"><dl><dt>[1]</dt><dd><div id="Wallerberger2023">M. Wallerberger, S. Badr, S. Hoshino, S. Huber, F. Kakizawa, T. Koretsune, Y. Nagai, K. Nogaki, T. Nomoto, H. Mori, J. Otsuki, S. Ozaki, T. Plaikner, R. Sakurai, C. Vogel, N. Witt, K. Yoshimi and H. Shinaoka, <em>sparse-ir: Optimal compression and sparse sampling of many-body propagators</em>. <a href="https://doi.org/10.1016/j.softx.2022.101266">SoftwareX <strong>21</strong>, 101266</a>.</div></dd><dt>[2]</dt><dd><div id="Helton2022">M. Helton and O. Smith. <a href="https://github.com/JuliaMath/Bessels.jl"><em>Bessels.jl</em></a>.</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../public/">Public »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Saturday 19 October 2024 21:27">Saturday 19 October 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
